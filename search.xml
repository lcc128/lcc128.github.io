<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis</title>
      <link href="/2022/01/15/redis/"/>
      <url>/2022/01/15/redis/</url>
      
        <content type="html"><![CDATA[<p> redisCache.setCacheObject(vkey, value,时间, 时间);</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql</title>
      <link href="/2021/10/03/MySql/"/>
      <url>/2021/10/03/MySql/</url>
      
        <content type="html"><![CDATA[<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p><img src="/images/20200818110848775.png" alt="7种连接查询"></p><h3 id="全连接-（查询双方都有的数据）-inner-join"><a href="#全连接-（查询双方都有的数据）-inner-join" class="headerlink" title="全连接 （查询双方都有的数据） inner join"></a>全连接 （查询双方都有的数据） inner join</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.列名,a.列名,b.列名 <span class="keyword">FROM</span> 表<span class="number">1</span> a  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> b <span class="keyword">ON</span> a.字段=b.字段 <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><h3 id="左连接-left-join"><a href="#左连接-left-join" class="headerlink" title="左连接 left join"></a>左连接 left join</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.列名,a.列名,b.列名 <span class="keyword">FROM</span> 表<span class="number">1</span> a  <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> b <span class="keyword">ON</span> a.字段=b.字段 <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><h3 id="右连接-right-join"><a href="#右连接-right-join" class="headerlink" title="右连接 right join"></a>右连接 right join</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.列名,a.列名,b.列名 <span class="keyword">FROM</span> 表<span class="number">1</span> a  <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> b <span class="keyword">ON</span> a.字段=b.字段 <span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>UNION 用于合并两个查询的结果集，以第一个查询的列名为对象，且输出列的字段保持一致</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> fullname <span class="keyword">FROM</span> yc_member <span class="keyword">WHERE</span> mem_name=<span class="string">'liuxueqin'</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> department_name <span class="keyword">from</span> yc_department <span class="keyword">WHERE</span> department_name <span class="keyword">LIKE</span> <span class="string">'%科%'</span></span><br></pre></td></tr></table></figure><h3 id="查询执行顺序"><a href="#查询执行顺序" class="headerlink" title="查询执行顺序"></a>查询执行顺序</h3><p>select–from–where–group by–having–order by</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段名 from 表名 where 条件</span><br></pre></td></tr></table></figure><p>connat（a，b）函数：拼接ab，并显示<br>    例如：concat（’姓名：’,username）<br>distinct 函数：去重复<br>limit （起始位置，长度）<br>abd（）绝对值<br>ceiling （）向上取整<br>floor （）向下取整<br>rand（） 返回0~1的一个随机数<br>sign（） 返回符号（判断正负）负数返回-1，正数返回1<br>char_length() 返回字符段长度</p><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>AVG() 平均值<br>count（） 记数<br>sum（） 求和<br>max（） 最大值<br>min（）最小值</p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>自己的表和自己连接，核心是将一个表拆分成两个表</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>涉及增删改以及多表是需要事务，要么都成功，有一个失败就数据回滚<br>事务原则： ACID原则<a href="https://blog.csdn.net/dengjili/article/details/82468576/" target="_blank" rel="noopener">https://blog.csdn.net/dengjili/article/details/82468576/</a><br>原子性（Atomicity，或称不可分割性）：要么都成功，要么都失败<br>一致性（Consistency）：事务前后的数据完整性要保持一致<br>隔离性（Isolation） ：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。<br>持久性（Durability） ：事务一旦提交就不可逆转</p><p>事务的隔离级别<br>  脏读：指一个事务读取了另一个未提交的事务<br>  不可重复度：一个事务内读取表中的某一行数据，多次读取结果不同。<br>  虚读：指在一个事务内读取到了别的事务插入的数据，导致前后读取数量总量不一致。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>帮助MySql更高效获得数据的一种数据结构</p><h3 id="主键索引-primary-key"><a href="#主键索引-primary-key" class="headerlink" title="主键索引 primary key"></a>主键索引 primary key</h3><p>  唯一标识，主键不可重复，只能有一个列作为主键</p><h3 id="唯一索引-unine-key"><a href="#唯一索引-unine-key" class="headerlink" title="唯一索引 unine key"></a>唯一索引 unine key</h3><p>  字段内不能出现重复的值，但是可以存在多个唯一索引</p><h3 id="常规索引-key"><a href="#常规索引-key" class="headerlink" title="常规索引 key"></a>常规索引 key</h3><h3 id="全文索引-fulltext"><a href="#全文索引-fulltext" class="headerlink" title="全文索引  fulltext"></a>全文索引  fulltext</h3><p>  快速定位数据</p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="第一范式-1NF-（原子性）"><a href="#第一范式-1NF-（原子性）" class="headerlink" title="第一范式 1NF （原子性）"></a>第一范式 1NF （原子性）</h3><p>要求数据库中的每一列都是不可再分割的数据项。</p><h3 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 2NF"></a>第二范式 2NF</h3><p>前提：满足第一范式<br>每张表只描述一件事情</p><h3 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 3NF"></a>第三范式 3NF</h3><p>前提；满足第一范式，第二范式<br>确保数据表中的每一列都和主键直接相关，而不能间接相关</p>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate—持久层框架</title>
      <link href="/2021/09/11/Hibernate/"/>
      <url>/2021/09/11/Hibernate/</url>
      
        <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mysql驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Hibernate核心驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.orm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.0.CR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span></span></span><br></pre></td></tr></table></figure><h3 id="2-创建Hibernate配置文件"><a href="#2-创建Hibernate配置文件" class="headerlink" title="2.创建Hibernate配置文件"></a>2.创建Hibernate配置文件</h3><p>创建hibernate.cfg.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='utf-8'?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!--声明Hibernate配置文件的开始--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>   <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>  jdbc:mysql://localhost:3306/hibernatestudy?=UTC&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>111111<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        C3P0--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        自增10--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.c3p0.acquire_increment"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.c3p0.idle_test_period"</span>&gt;</span>10000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.c3p0.timeout"</span>&gt;</span>5000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.c3p0.max_size"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.c3p0.min_size"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        最大线程数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.c3p0.max_statements"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        数据库方言--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        打印SQL--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        格式化SQL语句--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-创建实体类"><a href="#3-创建实体类" class="headerlink" title="3.创建实体类"></a>3.创建实体类</h3><h3 id="4-创建实体类-关系映射文件"><a href="#4-创建实体类-关系映射文件" class="headerlink" title="4.创建实体类-关系映射文件"></a>4.创建实体类-关系映射文件</h3><p>创建文件**.hbm.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.hibernate.domain.People"</span> <span class="attr">table</span>=<span class="string">"people"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"identity"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"money"</span> <span class="attr">type</span>=<span class="string">"java.lang.Double"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"money"</span>&gt;</span><span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-调用Hibernate-API完成操作"><a href="#5-调用Hibernate-API完成操作" class="headerlink" title="5.调用Hibernate-API完成操作"></a>5.调用Hibernate-API完成操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.hibernate.domain.People;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> Test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022/3/13 18:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by ThyAD</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Configuration configuration = <span class="keyword">new</span> Configuration().configure(<span class="string">"hibernate.cfg.xml"</span>);</span><br><span class="line">        <span class="comment">//获取SessionFactory</span></span><br><span class="line">        SessionFactory sessionFactory = configuration.buildSessionFactory();</span><br><span class="line">        <span class="comment">//获取Session</span></span><br><span class="line">        Session session = sessionFactory.openSession();</span><br><span class="line">        People people = <span class="keyword">new</span> People();</span><br><span class="line">        people.setId(<span class="number">1</span>);</span><br><span class="line">        people.setName(<span class="string">"张三"</span>);</span><br><span class="line">        people.setMoney(<span class="number">1000.0</span>);</span><br><span class="line">        session.save(people);</span><br><span class="line">        session.beginTransaction().commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h2><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p>客户和订单：每个客户可以购买多个产品，⽣成多个订单，但是⼀个订单只能属于⼀个客户，所以客户<br>是⼀，订单是多。<br>数据库中⼀的⼀⽅是主表，多的⼀⽅时候从表，通过主外键关系来维护。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//主表</span><br><span class="line">public class Customer &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private  String name;</span><br><span class="line">    private List&lt;Orders&gt; orders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.hibernate.domain.Customer"</span> <span class="attr">table</span>=<span class="string">"customer"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"identity"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span> <span class="attr">name</span>=<span class="string">"orders"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span> <span class="attr">column</span>=<span class="string">"cid"</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">one-to-many</span> <span class="attr">class</span>=<span class="string">"com.hibernate.domain.Orders"</span>&gt;</span><span class="tag">&lt;/<span class="name">one-to-many</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1.set 标签来配置实体类中的集合属性 orsers<br>2.name 实体类属性名<br>3.table 表名<br>4.key 外键<br>5.one-to-many 与集合泛型的实体类对应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//从表</span><br><span class="line">public class Orders &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Customer cid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.hibernate.domain.Orders"</span> <span class="attr">table</span>=<span class="string">"orders"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"identity"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">many-to-one</span> <span class="attr">name</span>=<span class="string">"customer"</span> <span class="attr">class</span>=<span class="string">"com.hibernate.domain.Customer"</span> <span class="attr">column</span>=<span class="string">"cid"</span>&gt;</span><span class="tag">&lt;/<span class="name">many-to-one</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>学⽣选课：⼀⻔课程可以被多个学⽣选择，⼀个学⽣可以选择多⻔课程，学⽣是多，课程也是多。<br>数据库中是通过两个⼀对多关系来维护的，学⽣和课程都是主表，额外增加⼀张中间表作为从表，两张<br>主表和中间表都是⼀对多关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line"> private Integer id;</span><br><span class="line"> private String name;</span><br><span class="line"> private Set&lt;Course&gt; courses;</span><br><span class="line">&#125;</span><br><span class="line">public class Course &#123;</span><br><span class="line"> private Integer id;</span><br><span class="line"> private String name;</span><br><span class="line"> private Set&lt;Account&gt; accounts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java,数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持久层框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StringBoot一Web</title>
      <link href="/2021/04/28/StringBoot%E2%80%94Web/"/>
      <url>/2021/04/28/StringBoot%E2%80%94Web/</url>
      
        <content type="html"><![CDATA[<blockquote><p>StringBoot Web项目开发笔记,IDEA版</p></blockquote><h2 id="导入静态资源"><a href="#导入静态资源" class="headerlink" title="导入静态资源"></a>导入静态资源</h2><h3 id="wabjars"><a href="#wabjars" class="headerlink" title="wabjars"></a>wabjars</h3><ul><li>访问wabjars官网</li><li>Maven方式导入依赖</li><li>导入测试地址<ul><li>localhost:8080/webjar/jquery/3.4.1/jquery.js</li></ul></li></ul><h3 id="本地导入"><a href="#本地导入" class="headerlink" title="本地导入"></a>本地导入</h3><ul><li>本地resource文件下建立<em>public</em>、<em>resource</em>文件夹</li><li>将相应的js静态资源拖入即可</li><li>导入测试地址<ul><li>localhost:8080/jquery.js</li></ul></li></ul><p>优先级：resource&gt;static(默认)&gt;public</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>```</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2021/04/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/04/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</p></blockquote><h2 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h2><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>[ABC]</td><td>匹配[…]中的所有字符</td></tr><tr><td>[^ABC]</td><td>匹配除了[…]中的所有字符</td></tr><tr><td>[A-Z]</td><td>[A-Z]表示一个区间，匹配所有的大写字母</td></tr><tr><td>[\s\S]</td><td>匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</td></tr><tr><td>\w</td><td>匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</td></tr></tbody></table><h2 id="非打印符号"><a href="#非打印符号" class="headerlink" title="非打印符号"></a>非打印符号</h2><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Freemarker—模块引擎</title>
      <link href="/2021/04/12/Freemarker%E2%80%94%E6%A8%A1%E5%9D%97%E5%BC%95%E6%93%8E/"/>
      <url>/2021/04/12/Freemarker%E2%80%94%E6%A8%A1%E5%9D%97%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java,Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前前端模块引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><img src="/images/849589-20190306165258970-1789860540.png" alt="排序算法"></p><p><img src="/images/849589-20180402133438219-1946132192.png" alt="img"></p><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数</li></ul><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成</li></ul><p><img src="/images/849589-20171015223238449-2146169197.gif" alt="冒泡排序"></p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><p><img src="/images/849589-20171015224719590-1433219824.gif" alt="选择排序"></p><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><img src="/images/849589-20171015225645277-1151100000.gif" alt="插入排序"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法,Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2021/04/11/Mybatis/"/>
      <url>/2021/04/11/Mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="Mybatis知识点"><a href="#Mybatis知识点" class="headerlink" title="Mybatis知识点"></a>Mybatis知识点</h2><h3 id="与"><a href="#与" class="headerlink" title="#{}与${}"></a>#{}与${}</h3><p>#{}是预编译处理，${}是字符串替换。</p><p> Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用PreparedStatement 的 set 方法来赋值；</p><p> Mybatis 在处理${}时，就是把${}替换成变量的值。</p><p>使用#{}可以有效的防止 SQL 注入，提高系统安全性。</p><h2 id="Mybatis配置"><a href="#Mybatis配置" class="headerlink" title="Mybatis配置"></a>Mybatis配置</h2><h3 id="1-在pom-xml导入依赖"><a href="#1-在pom-xml导入依赖" class="headerlink" title="1.在pom.xml导入依赖"></a>1.在pom.xml导入依赖</h3><p>mybatis<br>mysql<br>junit</p><h3 id="2-在src-main-resources创建mybatis-config-xml"><a href="#2-在src-main-resources创建mybatis-config-xml" class="headerlink" title="2.在src/main/resources创建mybatis-config.xml"></a>2.在src/main/resources创建mybatis-config.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单类别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"com.stringboot.domian.Department"</span> <span class="attr">alias</span>=<span class="string">"Department"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.stringboot.domian"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以创建多套连接，只能使用一套 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 连接池  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span>          </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/stringbootweb?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;zeroDateTimeBehavior=convertToNull&amp;amp;useSSL=true&amp;amp;serverTimezone=GMT%2B8"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"1111111"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/BlogMapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-编写Mybatis工具类"><a href="#3-编写Mybatis工具类" class="headerlink" title="3.编写Mybatis工具类"></a>3.编写Mybatis工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取SqlSessionFactory 对象</span></span><br><span class="line">            String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getsql</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-编写Myabatis配置文件"><a href="#4-编写Myabatis配置文件" class="headerlink" title="4.编写Myabatis配置文件"></a>4.编写Myabatis配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace绑定一个对应的mapper对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.example.stringboot.mapper.DepartmentMapper"</span>&gt;</span></span><br><span class="line">//parameterMap  参数</span><br><span class="line">//parameterType 参数类型</span><br><span class="line">//resultMap     返回 1个</span><br><span class="line">//resultType=   返回集类型 多个</span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectId"</span>  <span class="attr">resultType</span>=<span class="string">"com.example.stringboot.domian.Department"</span>&gt;</span></span><br><span class="line">      select * from stringbootweb.department</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Maven资源过滤，约定大于配置"><a href="#Maven资源过滤，约定大于配置" class="headerlink" title="Maven资源过滤，约定大于配置"></a>Maven资源过滤，约定大于配置</h3><p>放在pom.xml中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="调用数据"><a href="#调用数据" class="headerlink" title="调用数据"></a>调用数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得SqlSession对象</span></span><br><span class="line">       SqlSession session = MybatisUtils.getSqlSession();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//执行Sql</span></span><br><span class="line">           DepartmentMapper mapper = session.getMapper(DepartmentMapper.class);</span><br><span class="line">           List&lt;Department&gt; departments = mapper.getDeparmentList();</span><br><span class="line">           <span class="keyword">for</span> (Department depam: departments) &#123;</span><br><span class="line">               System.out.println(depam);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           session.close();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//增删改需要提交事务</span><br><span class="line">session.commit();</span><br><span class="line">//查找</span><br><span class="line">select * from stringbootweb.department where id=#&#123;id&#125;</span><br><span class="line">//插入</span><br><span class="line">insert into stringbootweb.department (id,departmentName) values (#&#123;id&#125;,#&#123;departmentname&#125;)</span><br><span class="line">//更新</span><br><span class="line">update stringbootweb.department set departmentName=#&#123;departmentname&#125; where id=#&#123;id&#125;;</span><br></pre></td></tr></table></figure><h3 id="属性名和字段名不一致"><a href="#属性名和字段名不一致" class="headerlink" title="属性名和字段名不一致"></a>属性名和字段名不一致</h3> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//数据库字段  id name pwd</span><br><span class="line">//实体类   id name passwold</span><br><span class="line"></span><br><span class="line"> //1.起别名</span><br><span class="line"> select id,name,pwd as passwold from stringbootweb.department where id=#&#123;id&#125;;</span><br><span class="line"></span><br><span class="line"> //2.resultMap结果集映射</span><br><span class="line"> <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"DepartmentMap"</span> <span class="attr">type</span>=<span class="string">"Department"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--column是数据库字段，property是实体类属性--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--复杂的对象单独处理，对象：association      集合：collection--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"pwd"</span>   <span class="attr">property</span>=<span class="string">"passwold"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDepartmentById"</span> <span class="attr">resultMap</span>=<span class="string">"DepartmentMap"</span>&gt;</span></span><br><span class="line">     select * from stringbootweb.department where id=#&#123;id&#125;;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="子查询（按照查询嵌套查询）"><a href="#子查询（按照查询嵌套查询）" class="headerlink" title="子查询（按照查询嵌套查询）"></a>子查询（按照查询嵌套查询）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 多对一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"departmap"</span> <span class="attr">type</span>=<span class="string">"employee"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--对象：associatio   多对一n      集合：collection   一对多</span></span><br><span class="line"><span class="comment">    javaType="" 指定属性的类型</span></span><br><span class="line"><span class="comment">    集合中的泛型信息，用ofType获取</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"department"</span> <span class="attr">column</span>=<span class="string">"department"</span> <span class="attr">javaType</span>=<span class="string">"Department"</span> <span class="attr">select</span>=<span class="string">"getpartmentNmae"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDepartmentname"</span> <span class="attr">resultMap</span>=<span class="string">"departmap"</span>&gt;</span></span><br><span class="line">    select * from stringbootweb.employee</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getpartmentNmae"</span> <span class="attr">resultType</span>=<span class="string">"Department"</span>&gt;</span></span><br><span class="line">    select * from stringbootweb.department where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="按照结果嵌套查询"><a href="#按照结果嵌套查询" class="headerlink" title="按照结果嵌套查询"></a>按照结果嵌套查询</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 多对一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"getDepartmentname2Map"</span> <span class="attr">type</span>=<span class="string">"employee"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"eid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"ename"</span> <span class="attr">property</span>=<span class="string">"lastname"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"department"</span> <span class="attr">javaType</span>=<span class="string">"Department"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"departmentname"</span> <span class="attr">column</span>=<span class="string">"dname"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDepartmentname2"</span> <span class="attr">resultMap</span>=<span class="string">"getDepartmentname2Map"</span>&gt;</span></span><br><span class="line">    select d.departmentName dname,e.lastname ename,e.id eid</span><br><span class="line">    from stringbootweb.department d,stringbootweb.employee e</span><br><span class="line">    where d.id=e.department;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="万能Map"><a href="#万能Map" class="headerlink" title="万能Map"></a>万能Map</h2><p>假如实体类或数据库字段较多，可以使用万能Map</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//万能Map。接口</span><br><span class="line">int addDepartment(Map<span class="tag">&lt;<span class="name">String,Object</span>&gt;</span> map);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addDepartment"</span> <span class="attr">parameterType</span>=<span class="string">"Map"</span> &gt;</span></span><br><span class="line">    insert into stringbootweb.department (id,departmentName) values (#&#123;id&#125;,#&#123;departmentname&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Department&gt; depList=mapper.getDepartmentLike(&quot;%李%&quot;);</span><br><span class="line">select * from stringbootweb.department where name like #&#123;value&#125;</span><br></pre></td></tr></table></figure><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p> Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件,可以控制每一条日志的输出格式,定义每一条日志信息的级别.可以通过一个配置文件来灵活地进行配置.</p><h3 id="1-配置mybatis-config-xml"><a href="#1-配置mybatis-config-xml" class="headerlink" title="1.配置mybatis-config.xml"></a>1.配置mybatis-config.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--标准STDOUT_LOGGING --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"LOG4J"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-Maven配置"><a href="#2-Maven配置" class="headerlink" title="2.Maven配置"></a>2.Maven配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-log4j配置文件"><a href="#3-log4j配置文件" class="headerlink" title="3.log4j配置文件"></a>3.log4j配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><br><span class="line">log4j.rootLogger=DEBUG,console,file</span><br><span class="line"></span><br><span class="line">#控制台输出的相关设置</span><br><span class="line">log4j.appender.console = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.Target = System.out</span><br><span class="line">log4j.appender.console.Threshold=DEBUG</span><br><span class="line">log4j.appender.console.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=[%c]-%m%n</span><br><span class="line"></span><br><span class="line">#文件输出的相关设置</span><br><span class="line">log4j.appender.file = org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.file.File=./log/thy.log</span><br><span class="line">log4j.appender.file.MaxFileSize=10mb</span><br><span class="line">log4j.appender.file.Threshold=DEBUG</span><br><span class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><br><span class="line"></span><br><span class="line">#日志输出级别</span><br><span class="line">log4j.logger.org.mybatis=DEBUG</span><br><span class="line">log4j.logger.java.sql=DEBUG</span><br><span class="line">log4j.logger.java.sql.Statement=DEBUG</span><br><span class="line">log4j.logger.java.sql.ResultSet=DEBUG</span><br><span class="line">log4j.logger.java.sql.PreparedStatement=DEBUG</span><br></pre></td></tr></table></figure><h3 id="4-配置导包输出日志"><a href="#4-配置导包输出日志" class="headerlink" title="4.配置导包输出日志"></a>4.配置导包输出日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static Logger logger = Logger.getLogger(StringbootApplicationTests.class);</span><br><span class="line"></span><br><span class="line">logger.info(&quot;info:进入test&quot;);</span><br><span class="line">logger.debug(&quot;info:debug&quot;);</span><br><span class="line">logger.error(&quot;info:error&quot;);</span><br></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="limit分页"><a href="#limit分页" class="headerlink" title="limit分页"></a>limit分页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//stratIndex开始位置，pageSize查询长度</span><br><span class="line">select * from user limit stratIndex,pageSize;</span><br></pre></td></tr></table></figure><h3 id="PageHelper分页"><a href="#PageHelper分页" class="headerlink" title="PageHelper分页"></a>PageHelper分页</h3><h5 id="1-导入Maven"><a href="#1-导入Maven" class="headerlink" title="1.导入Maven"></a>1.导入Maven</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- pagehelper分页插件 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="2-配置拦截器"><a href="#2-配置拦截器" class="headerlink" title="2.配置拦截器"></a>2.配置拦截器</h4><p>在mybatis配置文件下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.github.pagehelper.PageInterceptor"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"helperDialect"</span> <span class="attr">value</span>=<span class="string">"mysql"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 分页合理化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"reasonable"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 多数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"autoRuntimeDialect"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-在代码中使用"><a href="#3-在代码中使用" class="headerlink" title="3.在代码中使用"></a>3.在代码中使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> PageInfo&lt;User&gt;(list);</span><br><span class="line"><span class="comment">//一共几页</span></span><br><span class="line"><span class="keyword">int</span> i=pageInfo.getTotal();</span><br></pre></td></tr></table></figure><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>动态SQL是指根据不同的条件生成不同的SQL语句</p><h3 id="if-where"><a href="#if-where" class="headerlink" title="if where"></a>if where</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    动态SQL--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getselect"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"employee"</span>&gt;</span></span><br><span class="line">        SELECT * FROM stringbootweb.employee</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastname!= null"</span>&gt;</span></span><br><span class="line">                lastname=#&#123;lastname&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span></span><br><span class="line">                and id=#&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getchoose"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"employee"</span>&gt;</span></span><br><span class="line">    SELECT * FROM stringbootweb.employee</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span></span><br><span class="line">                id=#&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"lastname!=null"</span>&gt;</span></span><br><span class="line">                and lastname=#&#123;lastname&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">               gender=#&#123;gender&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类似于java中的switch</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    动态SQL set--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateLastnameInt"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> &gt;</span></span><br><span class="line">    update stringbootweb.employee</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastname!=null"</span>&gt;</span></span><br><span class="line">            lastname=#&#123;lastname&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender!=null"</span>&gt;</span></span><br><span class="line">            gender=#&#123;gender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SQL片段-代码复用"><a href="#SQL片段-代码复用" class="headerlink" title="SQL片段(代码复用)"></a>SQL片段(代码复用)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"sqlUpdate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastname!=null"</span>&gt;</span></span><br><span class="line">            lastname=#&#123;lastname&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender!=null"</span>&gt;</span></span><br><span class="line">            gender=#&#123;gender&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    include标签引入SQL片段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateLastnameInt"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    update stringbootweb.employee</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"sqlUpdate"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1.基于单表进行定义SQL片段<br>2.不要存在where标签</p><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>对一个集合进行遍历</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryAllByDateEmployeeList"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"employee"</span>&gt;</span></span><br><span class="line">    select * from stringbootweb.employee</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collection表示需要遍历的集合 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- item绑定的键值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"array"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">"or"</span>&gt;</span></span><br><span class="line">            id=#&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//测试</span><br><span class="line">@Test</span><br><span class="line">    void queryAllByDateEmployeeList()&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        HashMap map = new HashMap();</span><br><span class="line">        ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        array.add(1001);</span><br><span class="line">        array.add(1002);</span><br><span class="line">        map.put(&quot;array&quot;,array);</span><br><span class="line">        List&lt;Employee&gt; employeeList = mapper.queryAllByDateEmployeeList(map);</span><br><span class="line">        for (Employee employee : employeeList) &#123;</span><br><span class="line">            System.out.println(employee);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java,数据库## </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持久层框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iBatis—持久层框架</title>
      <link href="/2021/04/11/iBatis%E2%80%94%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"/>
      <url>/2021/04/11/iBatis%E2%80%94%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>iBatis</strong>是一个持久性框架，在自动化的 Java的 SQL 数据库和对象之间进行映射。该映射通过包装 XML 配置文件中的 SQL 语句从应用程序逻辑分离。</p></blockquote><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>由于iBayis配置文件是用xml写的，在访问数据库时会出现&lt;&gt;等有歧义，会编译失败，则需要使用<!--[CDATA[sql语句]]--></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line">SELECT *</span><br><span class="line">FROM PERSON</span><br><span class="line">WHERE AGE &gt; #value#</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure><h2 id="数据操作配置文件xml"><a href="#数据操作配置文件xml" class="headerlink" title="数据操作配置文件xml"></a>数据操作配置文件xml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE sqlMap PUBLIC &quot;-//ibatis.apache.org//DTD SQL Map 2.0//EN&quot; &quot;http://ibatis.apache.org/dtd/sql-map-2.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;sqlMap namespace=&quot;Employee&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;insert id=&quot;insert&quot; parameterClass=&quot;Employee&quot;&gt;</span><br><span class="line">      INSERT INTO EMPLOYEE(first_name, last_name, salary)</span><br><span class="line">      values (#first_name#, #last_name#, #salary#)</span><br><span class="line"></span><br><span class="line">      &lt;selectKey resultClass=&quot;int&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">         select last_insert_id() as id</span><br><span class="line">      &lt;/selectKey&gt;</span><br><span class="line">   &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">   &lt;select id=&quot;getAll&quot; resultClass=&quot;Employee&quot;&gt;</span><br><span class="line">      SELECT * FROM EMPLOYEE</span><br><span class="line">   &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/sqlMap&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Member user=new Member();</span><br><span class="line">int xx=sc.update(&quot;Employee.insert&quot;, user); //调用对用的sql语句</span><br></pre></td></tr></table></figure><p><em>java类通过<strong>namespace</strong>找到对应的sqlmap.xml文件，在通过id找到具体要执行的语句。</em></p><h2 id><a href="#" class="headerlink" title></a><typealias></typealias></h2><p><strong><typealias></typealias></strong>用于导入类，并给其一个别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//alias 属性，用于给类的别名</span><br><span class="line">//type 表示传入的对象的位置</span><br><span class="line">&lt;typeAlias alias=&quot;Region&quot; type=&quot;com.originsys.eap.domain.Region&quot;/&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java,数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持久层框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目笔记</title>
      <link href="/2021/04/11/%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/04/11/%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h4 id="通知公告模块"><a href="#通知公告模块" class="headerlink" title="通知公告模块"></a>通知公告模块</h4><p>Sys_notify</p><table><thead><tr><th>字段名</th><th>数据类型</th><th>注释</th></tr></thead><tbody><tr><td>notify_id</td><td>int</td><td>通知id 主键</td></tr><tr><td>black_id</td><td>int</td><td>内容id</td></tr><tr><td>notify_title</td><td>varchar(30)</td><td>通知标题</td></tr><tr><td>notify_keywords</td><td>varchar(255)</td><td>关键字</td></tr><tr><td>notify_source</td><td>varchar(20)</td><td>通知来源</td></tr><tr><td>notify_time</td><td>datetime</td><td>通知时间</td></tr><tr><td>notify_open</td><td>char(2)</td><td>是否显示</td></tr><tr><td>browse_number</td><td>int</td><td>浏览量</td></tr><tr><td>create_by</td><td>varchar(64)</td><td>创建者</td></tr><tr><td>create_time</td><td>datetime</td><td>创建时间</td></tr><tr><td>update_by</td><td>varchar(64)</td><td>修改者</td></tr><tr><td>update_time</td><td>datetime</td><td>修改时间</td></tr></tbody></table><p>Sys_notify_content</p><table><thead><tr><th>字段名</th><th>数据类型</th><th>注释</th></tr></thead><tbody><tr><td>notify_id</td><td>int</td><td>通知公告的id</td></tr><tr><td>notify_content</td><td>longtext</td><td>通知内容</td></tr><tr><td>black_id</td><td>in</td><td>内容id</td></tr></tbody></table><h4 id="留言模块"><a href="#留言模块" class="headerlink" title="留言模块"></a>留言模块</h4><p>Sys_message</p><table><thead><tr><th>字段名</th><th>数据类型</th><th>注释</th></tr></thead><tbody><tr><td>massage_id</td><td>int</td><td>留言id</td></tr><tr><td>user_id</td><td>int</td><td>用户id</td></tr><tr><td>massage_title</td><td>varchar(255)</td><td>留言标题</td></tr><tr><td>user_address</td><td>varchar(64)</td><td>用户地址</td></tr><tr><td>user_massage_open</td><td>char(2)</td><td>是否公开</td></tr><tr><td>user_massage_ip</td><td>varchar(128)</td><td>用户申请ip</td></tr><tr><td>is_transact</td><td>char(2)</td><td>是否办理</td></tr><tr><td>transcat_by</td><td>varcahr(64)</td><td>办理者</td></tr><tr><td>transact_time</td><td>datetime</td><td>办理时间</td></tr><tr><td>update_by</td><td>varchar(64)</td><td>修改者</td></tr><tr><td>update_time</td><td>datetime</td><td>修改时间</td></tr><tr><td>reply_unit</td><td>varchar(64)</td><td>回复单位</td></tr><tr><td>message_id</td><td>varchar(16)</td><td>办理编号</td></tr></tbody></table><p>Sys_message_content</p><table><thead><tr><th>字段名</th><th>数据类型</th><th>注释</th></tr></thead><tbody><tr><td>massage_id</td><td>int</td><td>留言id</td></tr><tr><td>message_content</td><td>longtext</td><td>留言内容</td></tr><tr><td>reply_content</td><td>longtext</td><td>回复内容</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java,数据库,笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解全家桶</title>
      <link href="/2021/04/11/%E6%B3%A8%E8%A7%A3/"/>
      <url>/2021/04/11/%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring 注解"></a>Spring 注解</h2><h3 id="Autowired-自动装配"><a href="#Autowired-自动装配" class="headerlink" title="@Autowired 自动装配"></a>@Autowired 自动装配</h3><p>用来装配bean，都可以写在字段上，或者方法上。<br>当Spring发现@Autowired注解时，将自动在代码上下文中找到和其匹配（默认是类型匹配）的Bean，并自动注入到相应的地方去。<br>默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired(required=false)</p><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>当一个接口有多个实现类时，就可以用此注解表明哪个实现类才是我们所需要的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;service1&quot;)</span><br><span class="line">private TestService testService;</span><br></pre></td></tr></table></figure><h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p>默认按 byName自动注入,@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略,可以指定那个类来实现，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略<br>(1)、@Resource后面没有任何内容，默认通过name属性去匹配bean，找不到再按type去匹配<br>(2)、指定了name或者type则根据指定的类型去匹配bean<br>(3)、指定了name和type则根据指定的name和type去匹配bean，任何一个不匹配都将报错</p><h3 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h3><p>@Service注解用于标注业务层组件，以注解的方式把这个类注入到spring配置中，不需要再在applicationContext.xml文件定义bean了，类似的还包括@Component、@Repository、@Controller。</p><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>标注一个类为Spring容器的Bean,泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><p>标识一个该类是Spring MVC controller处理器，@Controller对应表现层的Bean，也就是Action。用来创建处理http请求的对象</p><h3 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h3><p>@Repository对应数据访问层Bean<br>@Repository(value=”userDao”)注解是告诉Spring，让Spring创建一个名字叫”userDao”的UserDaoImpl实例。</p><h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>因为Spring默认产生的bean是单例的，假如我不想使用单例怎么办，xml文件里面可以在bean里面配置scope属性。</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>@Configration用于定制配置类，可以替换xml的配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。</p><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p>类定义处: 是一个用来处理请求地址映射的注解（将请求映射到对应的控制器方法中），相对于 WEB 应用的根目录。<br>方法处: 提供进一步的细分映射信息，相对于类定义处的 URL。<br> method 属性：主要用来定义接收浏览器发来的何种请求<br>    例如： @RequestMapping(value=”/login”,method=RequestMethod.GET) 来指定 login()方法 仅处理通过 GET 方式发来的请求，也各异定义多个 请求<br> params 属性：表示请求参数，也就是追加在URL上的键值对，多个请求参数以&amp;隔开<br>    例如：@RequestMapping(path = “/login”, params={“username=kolbe”,”password=123456”})，该方法将接收 /user/login 发来的请求，且请求参数必须为 username=kolbe&amp;password=123456<br> headers 属性：可以限制客户端发来的请求<br>    例如： @RequestMapping(path = “/login”, headers=”Host=localhost:8080”)表示只接收本机发来的请求</p><h3 id="GetMapping"><a href="#GetMapping" class="headerlink" title="@GetMapping"></a>@GetMapping</h3><p>和@RequestMapping的Get方法一样</p><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>该注解是作用在类上或方法上，是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据，需要注意的是在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。</p><h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p>@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value=&quot;/users/&#123;userId&#125;/topics/&#123;topicId&#125;&quot;)</span><br><span class="line">public String test(</span><br><span class="line">       @PathVariable(value=&quot;userId&quot;) int userId, </span><br><span class="line">       @PathVariable(value=&quot;topicId&quot;) int topicId)</span><br></pre></td></tr></table></figure><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h3><p>ModelAttribute可以应用在方法参数上或方法上，他的作用主要是当注解在方法参数上时会将注解的参数对象添加到Model中；当注解在请求处理方法Action上时会将该方法变成一个非请求处理的方法，但其它Action被调用时会首先调用该方法。</p><h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p>可以使用@Value, 可以properties文件中的配置值。比如我们开发项目时常常会有几种环境，比如dev环境，test环境等等，不同的环境某些参数就会不一样，配置文件不一样，这个时候就会用到@value注解了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Value(value = “$&#123;user.userName&#125;”)</span><br></pre></td></tr></table></figure><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>用于将请求参数区数据映射到功能处理方法的参数上，其中course_id就是接口传递的参数，id就是映射course_id的参数名，也可以不写value属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Resp test(@RequestParam(value=&quot;course_id&quot;) Integer id)&#123;</span><br><span class="line">        return Resp.success(customerInfoService.fetch(id));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="NonNull"><a href="#NonNull" class="headerlink" title="@NonNull"></a>@NonNull</h3><p>标注在方法、字段、参数上，表示对应的值可以为空。</p><h3 id="Nullable"><a href="#Nullable" class="headerlink" title="@Nullable"></a>@Nullable</h3><p>标注在方法、字段、参数上，表示对应的值不能为空。</p><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="useGeneratedKeys"><a href="#useGeneratedKeys" class="headerlink" title="useGeneratedKeys"></a>useGeneratedKeys</h3><p>自动生成主键，插入值是，若没有传入主键值，则根据该属性设置是否自动生成主键内容（true/flase）</p><h3 id="keyProperty"><a href="#keyProperty" class="headerlink" title="keyProperty"></a>keyProperty</h3><p>useGeneratedKeys属性生成的主键内容传到的数据库的那个字段中</p>]]></content>
      
      
      <categories>
          
          <category> Java,注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax—Web数据交互方法</title>
      <link href="/2021/04/11/Ajax%E2%80%94Web%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E6%96%B9%E6%B3%95/"/>
      <url>/2021/04/11/Ajax%E2%80%94Web%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Ajax</strong>即Asynchronous Javascript And XML（异步JavaScript和XML）,是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p></blockquote><h2 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h2><p>jsp导入静态资源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/static/js.jquery.js"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><p>Json使用{}包裹起来，使用：区分key、value，多个值用逗号分开，且最后一个值不加逗号。<br>{“name”:”张三”,”sex”:”男”,”age”:18}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//将js对象转换成JSON字符串</span><br><span class="line">var obj = Json.stringify( js对象 );</span><br><span class="line"></span><br><span class="line">//将JSON字符串转换成js对象</span><br><span class="line">var obj = Json.parse( json字符串 );</span><br></pre></td></tr></table></figure><h3 id="Json解析工具"><a href="#Json解析工具" class="headerlink" title="Json解析工具"></a>Json解析工具</h3><p>Jackson</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper=<span class="keyword">new</span> ObjectMapper();</span><br><span class="line">User user=<span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">//将user对象转化成json数据</span></span><br><span class="line">String str=mapper.writeValueAstoString();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java,Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前后端数据交互 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2021/04/10/CSS/"/>
      <url>/2021/04/10/CSS/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>CSS</strong> 指的是层叠样式表,描述了如何在屏幕、纸张或其他媒体上显示 HTML 元素,节省了大量工作。它可以同时控制多张网页的布局</p></blockquote><h2 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h2><p><img src="/images/CSS%E8%AF%AD%E6%B3%95.gif" alt="CSS语法"></p><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><h3 id="颜色背景设置"><a href="#颜色背景设置" class="headerlink" title="颜色背景设置"></a>颜色背景设置</h3><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>color</td><td>设置字体颜色</td></tr><tr><td>background-color</td><td>设置背景颜色</td></tr><tr><td>opacity：0.0-1.0</td><td>设置不透明度</td></tr><tr><td>rgba(red, green, blue, alpha)</td><td>设置指定颜色的不透明度</td></tr></tbody></table><h3 id="图片背景"><a href="#图片背景" class="headerlink" title="图片背景"></a>图片背景</h3><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>background-image: url(“/i/paper.jpg”)</td><td>设置指定图片为背景</td></tr><tr><td>backfround-size：20px</td><td>指定背景图片的大小</td></tr><tr><td>background-repeat: repeat-x;</td><td>设置图片的方向</td></tr><tr><td>background-repeat: no-repeat;</td><td>设置图片背景只显示一次</td></tr><tr><td>background-position: right top;</td><td>设置图片背景的位置</td></tr><tr><td>background-attachment: fixed;</td><td>指定图片背景的位置是固定的</td></tr></tbody></table><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p><strong>border-style</strong> 属性指定要显示的边框类型</p><ul><li>dotted - 定义点线边框</li><li>dashed - 定义虚线边框</li><li>solid - 定义实线边框</li><li>double - 定义双边框</li><li>groove - 定义 3D 坡口边框。效果取决于 border-color 值</li><li>ridge - 定义 3D 脊线边框。效果取决于 border-color 值</li><li>inset - 定义 3D inset 边框。效果取决于 border-color 值</li><li>outset - 定义 3D outset 边框。效果取决于 border-color 值</li><li>none - 定义无边框</li><li>hidden - 定义隐藏边框</li></ul><p><img src="/images/css%E8%BE%B9%E6%A1%86.png" alt="css边框"></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 页面美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python一函数库</title>
      <link href="/2020/03/03/Python%E2%80%94%E5%87%BD%E6%95%B0%E5%BA%93/"/>
      <url>/2020/03/03/Python%E2%80%94%E5%87%BD%E6%95%B0%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="math库"><a href="#math库" class="headerlink" title="math库"></a>math库</h1><p><strong>math</strong>库是Python提供的内置数学类函数库，只支持整数和浮点数的运行，不支持复数。</p><h2 id="库函数引用"><a href="#库函数引用" class="headerlink" title="库函数引用"></a>库函数引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#第一种</span><br><span class="line">import math</span><br><span class="line">math.ceil (10.2)</span><br><span class="line"></span><br><span class="line">#第二种</span><br><span class="line">from math import floor</span><br><span class="line">floor (10.2)</span><br></pre></td></tr></table></figure><h2 id="数学常数"><a href="#数学常数" class="headerlink" title="数学常数"></a>数学常数</h2><table><thead><tr><th>常数</th><th>数学表示</th><th>描述</th></tr></thead><tbody><tr><td>math.pi</td><td>π</td><td>圆周率</td></tr><tr><td>math.e</td><td>e</td><td>自然对数</td></tr><tr><td>math.inf</td><td>∞</td><td>正无穷大</td></tr><tr><td>math.nan</td><td></td><td>非浮点数标记</td></tr></tbody></table><h2 id="数字表示函数"><a href="#数字表示函数" class="headerlink" title="数字表示函数"></a>数字表示函数</h2><table><thead><tr><th>函数</th><th>数学表示</th><th>描述</th></tr></thead><tbody><tr><td>math.fabs (x)</td><td>|x|</td><td>返回x的绝对值</td></tr><tr><td>math.fmod（x,y）</td><td>x%y</td><td>返回x于y的摸</td></tr><tr><td>math.fsum ([x,y,…])</td><td>x+y+…</td><td>浮点数精度求和</td></tr><tr><td>math.ceil (x)</td><td>⌈x⌉</td><td>向上取整，返回不小于x的最小整数</td></tr><tr><td>math.floor (x)</td><td>⌊x⌋</td><td>向下取整，返回不大于x的最大整数</td></tr><tr><td>math.factorial (x)</td><td>x!</td><td>返回x的阶乘</td></tr><tr><td>math.gcd (a,b)</td><td></td><td>返回a与b的最大公约数</td></tr><tr><td>math.frexp (x)</td><td>x=m*2^e</td><td>返回（m,e），当x=0，返回（0.0,0）</td></tr><tr><td>math.ldexp (x,i)</td><td>x*2^i</td><td>返回运算值</td></tr><tr><td>math.modf (x)</td><td></td><td>返回x的小数和整数部分</td></tr><tr><td>math.trunc (x)</td><td></td><td>返回x的整数部分</td></tr><tr><td>math.copysign (x,y)</td><td></td><td>用数字y的正负号替换数值x的正负号</td></tr></tbody></table><h2 id="幂对数函数"><a href="#幂对数函数" class="headerlink" title="幂对数函数"></a>幂对数函数</h2><table><thead><tr><th>函数</th><th>数学表示</th><th>描述</th></tr></thead><tbody><tr><td>math.pow (x,y)</td><td>x^y</td><td>返回x的y次幂</td></tr><tr><td>math.exp (x)</td><td>e^x</td><td>返回e的x次幂</td></tr><tr><td>math.expml (x)</td><td>e^x-1</td><td>返回e的x次幂减1</td></tr><tr><td>math.sqrt (x)</td><td>√x</td><td>返回x的平方根</td></tr><tr><td>math.log (x[,base])</td><td></td><td>返回x的对数值</td></tr><tr><td>math.log1p (x)</td><td>ln(1+x)</td><td>返回1+x的自然对数</td></tr><tr><td>math.log2 (x)</td><td>logˇ2x</td><td>返回x的2对数值</td></tr><tr><td>math.log10 (x)</td><td>logˇ10x</td><td>返回x的10的对数值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python一基础</title>
      <link href="/2020/03/01/Python%E2%80%94%E5%BE%AA%E7%8E%AF/"/>
      <url>/2020/03/01/Python%E2%80%94%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Python格式框架"><a href="#Python格式框架" class="headerlink" title="Python格式框架"></a>Python格式框架</h1><p>Python采用严格的缩进来表明程序的格式框架。可使用Tab键或者4个空格实现。</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p><img src="/images/%E5%BA%8F%E5%8F%B7%E4%BD%93%E7%B3%BB.jpg" alt="序号体系"></p><p>Python支持单个字符访问和区间访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = &quot;10000000&quot;</span><br><span class="line">print ( i[1] )           #单个字符访问</span><br><span class="line">print ( i[1,9] )         #字符区间访问</span><br></pre></td></tr></table></figure><blockquote><p>内置字符串处理函数</p></blockquote><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>len (x)</td><td>返回字符串x的长度，也可以返回其他组合数据类型的元素个数</td></tr><tr><td>str (x)</td><td>返回任意类型x所对应的字符串形式</td></tr><tr><td>chr (x)</td><td>返回Unicode编码x对应的单字符</td></tr><tr><td>ord (x)</td><td>返回单字符表示的Unicode编码</td></tr><tr><td>hex (x)</td><td>返回整数x对应十六进制数的小写形式字符串</td></tr><tr><td>oct (x)</td><td>返回整形x对应八进制的小写形式字符串</td></tr></tbody></table><blockquote><p>常用的内置字符串处理方法</p></blockquote><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>str.lower ()</td><td>返回字符串str的副本，全部字符小写</td></tr><tr><td>str.upper ()</td><td>返回字符串str的副本，全部字符大写</td></tr><tr><td>str.islower ()</td><td>当str所有字符都是小写时，返回True，否则返回False</td></tr><tr><td>str.isprintable ()</td><td>当str所有字符都是可打印时，返回True，否则返回False</td></tr><tr><td>str.isnumeric ()</td><td>当str所有字符都是数字时，返回True，否则返回False</td></tr><tr><td>str.isspace ()</td><td>当str所有字符都是空格时，返回True，否则返回False</td></tr><tr><td>str.endswith (suffix [,start [,end]])</td><td>str[start:end]以suffix结尾返回True，否则返回False</td></tr><tr><td>str.startwith (prefix [,start [,end]])</td><td>str[start:end]以prefix结尾返回True，否则返回False</td></tr><tr><td>str.split(sep=None,maxsplit=-1)</td><td>返回一个列表，由str根据sep被分隔的部分构成</td></tr><tr><td>str.count(sub [,start [,end]])</td><td>返回str[start:end]中sub子串出现的次数</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td># 输入输出函数</td><td></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = intput (&quot;待输出字符串&quot;)           #输入函数</span><br><span class="line">print （&quot;待输出字符串&quot;.format(i)）    #输出函数</span><br></pre></td></tr></table></figure><h1 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h1><p>eval() 函数用来执行一个字符串表达式，并返回表达式的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = 7</span><br><span class="line">y = eval(&quot;x * 8&quot;)                 #用于计算</span><br><span class="line">print ( eval(&quot;x * 9&quot;) )    </span><br><span class="line">x = eval (input (&quot;请输入数字&quot;))   #输入数字并计算</span><br><span class="line">print (x+1)</span><br></pre></td></tr></table></figure><h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if &lt;条件1&gt; :</span><br><span class="line">   &lt;语句块1&gt;</span><br><span class="line">elif &lt;条件2&gt; :</span><br><span class="line">   &lt;语句块2&gt;</span><br><span class="line">...</span><br><span class="line">else :</span><br><span class="line">   &lt;语句块N&gt;</span><br></pre></td></tr></table></figure><h1 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (&lt;条件&gt;) :</span><br><span class="line">   &lt;语句块1&gt;</span><br><span class="line">&lt;语句块2&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java一多线程</title>
      <link href="/2020/01/06/Java%E4%B8%80%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/01/06/Java%E4%B8%80%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在计算机多任务操作系统中，计算机能够同时执行多个应用程序（进程），表面上看是支持进程并发执行的，实际上对于CPU来说，在某个时间点只能运行一个进程。操作系统会为每一个进程分配一段悠闲的CPU使用时间，CPU在这段时间中执行某个进程，然后会在下一段时间切换到另一个进程中去执行。由于CPU运行速度很快，能在极短的时间内在不同进程之间进行切换，所以给人以同时执行多个进程的感觉。进程中有很多执行单元组成，这一个个的执行单元被称为线程。</p></blockquote><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>线程的创建有两种方式，一种是继承java.lang包下Thread类，重写Thread类的run（）方法。另一种是实现java.lang.Runnable接口。</p><h3 id="通过继承Thread类来实现多线程"><a href="#通过继承Thread类来实现多线程" class="headerlink" title="通过继承Thread类来实现多线程"></a>通过继承Thread类来实现多线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main (String [] args)&#123;</span><br><span class="line">Thread myThread= new Task();</span><br><span class="line">new Thread (myThread,&quot;窗口1&quot;).start();     //给线程命名，并创建线程</span><br><span class="line">new Thread (myThread,&quot;窗口2&quot;).start();</span><br><span class="line">System.out.println (Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Task extends Thread&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println (Thread.currentThread().getName()+&quot;执行&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过Runnable接口实现多线程"><a href="#通过Runnable接口实现多线程" class="headerlink" title="通过Runnable接口实现多线程"></a>通过Runnable接口实现多线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">Task myThread= new Task();</span><br><span class="line">new Thread (myThread,&quot;窗口1&quot;).start();</span><br><span class="line">new Thread (myThread,&quot;窗口2&quot;).start();</span><br><span class="line">System.out.println (Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Task implements Runnable&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println (Thread.currentThread().getName()+&quot;执行&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程的生命周期及其转换状态"><a href="#线程的生命周期及其转换状态" class="headerlink" title="线程的生命周期及其转换状态"></a>线程的生命周期及其转换状态</h2><p><img src="/images/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.jpg" alt="线程状态转换图"></p><ol><li><p><strong>新建状态（new）</strong>：线程对象被创建后就进入了新建状态，此时它不能进行运行，只是被Java虚拟机分配了内存。如：Thread thread = new Thread();</p></li><li><p><strong>就绪状态（Runnable）</strong>：也被称为“可执行状态”。线程对象被创建后，其他线程调用了该对象的start()方法，从而启动该线程。如：thread.start(); 处于就绪状态的线程随时可能被CPU调度执行。</p></li><li><p><strong>运行状态（Running）</strong>：线程获取CPU权限进行执行,并且开始执行run()方法中的线程执行题。需要注意的是，线程只能从就绪状态进入到运行状态。</p></li><li><p><strong>阻塞状态（Blocked）</strong>：阻塞状态是线程因为某种原因放弃CPU使用权限，暂时停止运行。直到线程进入就绪状态，才有机会进入运行状态。阻塞的三种情况：</p><ol><li><p>等待阻塞：通过调用线程的wait()方法，让线程等待某工作的完成。</p></li><li><p>同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态。</p></li><li><p>其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或超时、或者I/O处理完毕时，线程重新转入就绪状态。</p></li></ol></li><li><p><strong>死亡状态（Dead）</strong>：当线程调用stop（）方法或run（）方法正常执行完毕后，或线程抛出了一个未捕获的异常、错误线程进入死亡状态，该线程结束生命周期。</p></li></ol><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>  程序中的多个线程是并发执行的，某个线程若想被执行必须要得到CPU的使用权。</p><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>  如果要对线程进行调度，最直接的方式就是设置线程的优先级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Thread maxThread= new Thread(new Task(),&quot;高优先级&quot;);</span><br><span class="line">    Thread minThread= new Thread(new Task(),&quot;低优先级&quot;);</span><br><span class="line">    maxThread.setPriority( Thread.MAX_PRIORITY );        //设置线程的优先级，默认是5，最高是10，最低是1</span><br><span class="line">    minThread.setPriority( Thread.MIN_PRIORITY );</span><br><span class="line">    maxThread.start();</span><br><span class="line">    minThread.start();</span><br><span class="line">System.out.println (Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Task implements Runnable&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println (Thread.currentThread().getName()+&quot;执行&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><p>   线程休眠可以将正在进行的线程进行暂停，将CPU让给别的线程，使用静态方法<strong>sleep(long millis)</strong>.当方法执行sleep （long millis）方法后，在指定的时间内线程是不会执行的。</p><ol><li>使用sleep （long millis）方法声明会抛出InterruptedExcept异常，因此在调用该方法是应该捕获异常，或者是将异常抛出。</li><li>sleep （long millis）是静态方法，只能控制当前正在运行的线程休眠。线程休眠结束后返回到就绪状态，而不是立即执行。</li></ol><h3 id="线程插队"><a href="#线程插队" class="headerlink" title="线程插队"></a>线程插队</h3><p>   在Thread类中也提供了一个join（）方法来实现插队功能。当在某个线程中调用其他线程的join（）方法时，调用的线程将被阻塞，直到被join（）方法加入的线程执行完成后它才会继续执行运行。</p><h2 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h2><p>当多个线程去访问一个资源时，可能会出现处理资源不符合实际情况，这需要实现多线程的同步，即限制摸个资源在同一时刻只能别一个线程访问。</p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (lock)&#123;</span><br><span class="line">    操作共享资源代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其中lock是一个锁对象，它是同步代码块的关键。当某一个线程执行同步代码块时，其他线程无法执行当前同步代码块，会发生阻塞，等当前线程执行完同步代码块后，所有线程开始抢夺线程的执行权，抢到执行权的线程会进去同步代码块，执行其中的代码。</li><li>同步代码块的锁对象可以是任意类型的对象，单多个线程共享的锁对象必须是唯一的。</li><li>锁对象的创建代码不能放入run（）方法中。</li></ul><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized 返回值类型 方法名 （[参数1]···）&#123;</span><br><span class="line">    操作代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized修饰静态方法，如果调用该静态方法，将锁住整个类。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>同步方法默认用this或者当前类class对象作为锁。</li><li>同步代码块可以选择以什么来加锁，比同步方法要更颗粒化，我们可以选择只同步会发生问题的部分代码而不是整个方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java一JDBC</title>
      <link href="/2020/01/01/Java%E2%80%94JDBC/"/>
      <url>/2020/01/01/Java%E2%80%94JDBC/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>JDBC</strong>：全称Java数据库连接（Java Datebase Connextivity），它是一套用于执行SQL语句的Java API。应用程序可以通过这套API连接到关系型数据库，并使用SQL语句来完成对数据库中的数据进行的操作。</p></blockquote><p><img src="/images/JDBC.png" alt="JDBC"></p><h2 id="JDBC常用API"><a href="#JDBC常用API" class="headerlink" title="JDBC常用API"></a>JDBC常用API</h2><p>JDBC API主要位于Java.sql包中。</p><h3 id="Driver接口"><a href="#Driver接口" class="headerlink" title="Driver接口"></a>Driver接口</h3><p><strong>Driver</strong>接口是所有JDBC驱动程序必须实现的接口，该接口专门提供给数据库厂商使用。</p><h3 id="DriverManager类"><a href="#DriverManager类" class="headerlink" title="DriverManager类"></a>DriverManager类</h3><p><strong>DriverManager</strong>类用于加载JDBC驱动并且创建与数据库的连接。</p><table><thead><tr><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>static void registerDriver (Driver driver)</td><td>该方法用于向DriverManager中注册给定的JDBC驱动程序</td></tr><tr><td>static Connection getConnection (String url,String user,String pwd)</td><td>该方法用于建立和数据库的连接，并返回表示连接的Connection对象</td></tr></tbody></table><h3 id="Connection接口"><a href="#Connection接口" class="headerlink" title="Connection接口"></a>Connection接口</h3><p><strong>Connection</strong>接口代表Java程序和数据库的连接，只有获得该连接对象后，才能访问数据库，并操作数据表。</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>DatabaseMetaData_getMetaData ( )</td><td>该方法用于返回表示数据库的元数据的DatabaseMetaData对象</td></tr><tr><td>Statement createStatement （ ）</td><td>用于创建一个Statement对象来将SQL语句发送到数据库</td></tr><tr><td>PreparedStatement prepareStatement （String sql）</td><td>用于创建一个PreparedStatement对象来将参数化的SQL语句发送到数据库</td></tr><tr><td>CallableStatement perpareCall （String sql）</td><td>用于创建一个CallableStatement对象来调节数据库存储过程</td></tr></tbody></table><h3 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h3><p><strong>Statement</strong>接口用于执行静态的SQL语句。并返回一个结果对象。</p><table><thead><tr><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>boolean execute (String sql)</td><td>用于只想各种SQL语句，该方法返回一个boolean类型的字，true：表示所执行SQL语句。可通过Statement的getResultSet（）方法获得查询结果</td></tr><tr><td>int executeUpdate （String sql）</td><td>用于执行SQL中的insert,update和delete语句。返回一个int类型的值，表示数据库中受到处理的记录条数</td></tr><tr><td>ResultSet executeQuery（String sql）</td><td>用于执行SQL语句中的select语句。该方法返回一个表示查询结果的ResultSet对象</td></tr></tbody></table><h3 id="PrepareStatement接口"><a href="#PrepareStatement接口" class="headerlink" title="PrepareStatement接口"></a>PrepareStatement接口</h3><p><strong>PreparedStatement</strong>是Statement的子接口，用于执行预编译的SQL语句。在Java程序开发过程中，由于对于数据的查询往往是一个变值，所以Statement便不再满足程序的需求。</p><table><thead><tr><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>int excuteUpate ()</td><td>在此对象中执行SQL语句，该语句必须是一个DML语句或者是无返回内容的SQL语句。例如DDL语句</td></tr><tr><td>ResultSet executeQuery（）</td><td>在此对象中执行SQL语句，该方法返回的是ResultSet对象</td></tr><tr><td>void setInt （int parameterIndex，int x）</td><td>将指定参数设置为给定的int值</td></tr><tr><td>void setFloat （int parameterIndex，float x）</td><td>将指定参数设置为给定的float值</td></tr><tr><td>void setString （int parameterIndex，String x）</td><td>将指定的参数设置为给定的String值</td></tr><tr><td>void setDate （int parameterIndex，Date x）</td><td>将指定的参数设置为给定的Date值</td></tr><tr><td>void addBatch（）</td><td>将一组参数添加到此PrepareStatement对象的批处理命令中</td></tr><tr><td>void setCharacterStream （int parameterIndex，java.io.Reader reder,int length）</td><td>将指定的输入流写入数据库的文本字段</td></tr><tr><td>void setBinaryStream （int parameterIndex，java.InputStream x,int length）</td><td>将二进制的输入流数据写入到二进制字段中</td></tr></tbody></table><h3 id="ResultSet接口"><a href="#ResultSet接口" class="headerlink" title="ResultSet接口"></a>ResultSet接口</h3><p><strong>ResultSet</strong>接口用于保存JDBC执行查询时返回的结果集，该结果集封装在一个逻辑表格中。</p><table><thead><tr><th>方法名称</th><th>功能描述</th></tr></thead><tbody><tr><td>String getString （int columnIndex）</td><td>用于获取指定字段的String类型的值，参数代表字段的索引</td></tr><tr><td>String getString （String columnName）</td><td>用于获取指定字段的String类型的值，参数代表字段的名称</td></tr><tr><td>int getInt （int columnIndex）</td><td>用于获取指定字段的Int类型的值，参数代表字段的索引</td></tr><tr><td>int getInt （String columnName）</td><td>用于获取指定字段的Int类型的值，参数代表字段的名称</td></tr><tr><td>Date getDate （int columnIndex）</td><td>用于获取指定字段的Date类型的值，参数代表字段的索引</td></tr><tr><td>Date getDate (String columnName)</td><td>用于获取指定字段的Date类型的值，参数代表字段的名称</td></tr><tr><td>boolean next （）</td><td>将游标从当前位置向下移一行</td></tr><tr><td>boolean absolute （int row）</td><td>将游标移动到此ResultSet对象的指定行</td></tr><tr><td>void afterLast （）</td><td>将游标移动到此ResultSet对象的末尾，即最后一行之后</td></tr><tr><td>void beforeFirst （）</td><td>将游标移动到此ResultSet对象的开头，即第一行之前</td></tr><tr><td>boolean previous （）</td><td>将游标移动到此ResultSet对象的上一行</td></tr><tr><td>boolean last （）</td><td>将游标移动到此ResultSet对象的最后一行</td></tr></tbody></table><h2 id="JDBC程序设计步骤"><a href="#JDBC程序设计步骤" class="headerlink" title="JDBC程序设计步骤"></a>JDBC程序设计步骤</h2><h3 id="1-加载并注册数据库驱动"><a href="#1-加载并注册数据库驱动" class="headerlink" title="1.加载并注册数据库驱动"></a>1.加载并注册数据库驱动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.registerDriver （Driver driver）;</span><br><span class="line">或</span><br><span class="line">Class.forName (&quot;DriverName&quot;);</span><br></pre></td></tr></table></figure><h3 id="2-通过DriverManager获取数据库连接"><a href="#2-通过DriverManager获取数据库连接" class="headerlink" title="2.通过DriverManager获取数据库连接"></a>2.通过DriverManager获取数据库连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection (String url,String user,String pwd);</span><br></pre></td></tr></table></figure><h3 id="3-通过Conection对象获取Statement对象"><a href="#3-通过Conection对象获取Statement对象" class="headerlink" title="3.通过Conection对象获取Statement对象"></a>3.通过Conection对象获取Statement对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt = conn.createStatement ();</span><br></pre></td></tr></table></figure><h3 id="4-使用Statement执行SQL语句"><a href="#4-使用Statement执行SQL语句" class="headerlink" title="4.使用Statement执行SQL语句"></a>4.使用Statement执行SQL语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//执行SQL语句，获取结果集ResultSet</span><br><span class="line">ResultSet rs = stmt.executeQuery (sql);</span><br></pre></td></tr></table></figure><h3 id="5-操作ResultSet结果集"><a href="#5-操作ResultSet结果集" class="headerlink" title="5.操作ResultSet结果集"></a>5.操作ResultSet结果集</h3><h3 id="6-关闭连接，释放资源"><a href="#6-关闭连接，释放资源" class="headerlink" title="6.关闭连接，释放资源"></a>6.关闭连接，释放资源</h3><h2 id="IDEA连接MySql数据库源码"><a href="#IDEA连接MySql数据库源码" class="headerlink" title="IDEA连接MySql数据库源码"></a>IDEA连接MySql数据库源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//注册驱动</span><br><span class="line">Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">//创建连接</span><br><span class="line">Connection conn= DriverManager.getConnection</span><br><span class="line">     (&quot;jdbc:mysql://localhost/student?useSSL=FALSE&amp;serverTimezone=UTC&quot;,&quot;root&quot;,&quot;Thy128&quot;);</span><br><span class="line">//得到执行sql语句的Statement对象</span><br><span class="line">Statement stmt=conn.createStatement();</span><br><span class="line"> //执行sql语句，并返回结果</span><br><span class="line"> ResultSet rs=stmt.executeQuery(&quot;select * from stu&quot;);</span><br><span class="line">//处理结果</span><br><span class="line"> while (rs.next()) &#123;</span><br><span class="line">        System.out.print(&quot;id=&quot;+ rs.getObject(&quot;no&quot;)+&quot;     &quot;);</span><br><span class="line">        System.out.println(&quot;name=&quot;+ rs.getObject(&quot;name&quot;));</span><br><span class="line">        System.out.println(&quot;==========================&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">//关闭资源</span><br><span class="line">rs.close();</span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h3 id="Statment执行SQL对象"><a href="#Statment执行SQL对象" class="headerlink" title="Statment执行SQL对象"></a>Statment执行SQL对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;select * from stu&quot;;      //编写SQL</span><br><span class="line"></span><br><span class="line">stmatement.executeQuery()              //查询操作，返回resultSet结果集</span><br><span class="line">stmatement.execute（）                 //执行任何SQL语句</span><br><span class="line">stmatement.executeUpdate()             //跟新、插入、删除。返回一个受影响的行数</span><br></pre></td></tr></table></figure><h3 id="ResultSet查询的结果集"><a href="#ResultSet查询的结果集" class="headerlink" title="ResultSet查询的结果集"></a>ResultSet查询的结果集</h3><h4 id="获得指定的数据类型"><a href="#获得指定的数据类型" class="headerlink" title="获得指定的数据类型"></a>获得指定的数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resultSet.getObject();      //获得任何类型</span><br><span class="line">resultSet.getInt();         //获得Int型数据</span><br><span class="line">resultSet.getString();</span><br><span class="line">resultSet.getDouble();</span><br><span class="line">resultSet.getDate();</span><br><span class="line">......</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java一GUI</title>
      <link href="/2019/11/15/Java%E4%B8%80GUI/"/>
      <url>/2019/11/15/Java%E4%B8%80GUI/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>GUI</strong>(图形用户界面):应用程序提供给用户操作的图形界面，包括窗口、菜单、按钮、工具栏和其他各种图形界面元素。Java中针对GUI设计提供了类，分别位于java.awt和java.swing包中，简称AWT和Swing。</p></blockquote><h2 id="AWT"><a href="#AWT" class="headerlink" title="AWT"></a>AWT</h2><p>AWT利用本地操作系统所提供的图形库，不能跨平台使用。在AWT中组件可以分为<strong>Component</strong>和<strong>MenuComponent</strong>，其中MenuComponent是所有与菜单相关组件的父类，而Component则与之相反。</p><p><img src="/images/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt="继承关系图"></p><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p><strong>Container</strong>:属于Component的子类，而它则表示容器，是一种特殊的组件，可以用来容纳其他组件。其可以分为Window和Panel两种类型。</p><p>1.<strong>Window</strong>:是独立存在的容器，有Frame和Dialog两个子类。<br>  (1).<strong>Frame</strong>类用于创建一个具有标题栏的框架窗口，作为主程序界面。<br>  (2).<strong>Panel</strong>类用于创建一个对话框，实现与用户的信息交互。<br>2.<strong>Panel</strong>是一个不能单独存在的容器，只能存在其他容器（Window或其他子类）中。一个Panel对象代表一个长方形区域。</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>setSize(int high,int width)</td><td>设置窗体对象的高度和宽度。</td></tr><tr><td>setLocation(int x,int y)</td><td>设置窗体对象在屏幕中所处的坐标位置。</td></tr><tr><td>setVisible(boolean true)</td><td>设置窗体对象是否处于隐藏状态。</td></tr><tr><td>setlayout(new FlowLayout())</td><td>设置窗体对象布局的样式。</td></tr></tbody></table><h3 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h3><p>在AWT中，组件无法单独存在，需要处于容器中，而组件在容器中的位置样式则是由布局管理器控制的。在AWT中，提供了5种布局管理器样式。</p><h4 id="FiowLayout（流式布局管理器）"><a href="#FiowLayout（流式布局管理器）" class="headerlink" title="FiowLayout（流式布局管理器）"></a>FiowLayout（流式布局管理器）</h4><p><strong>FlowLayout</strong>的特点是所有组件像流水一样一次排列排列，不需要明确设置，缺点是没有那么灵活。<br><img src="/images/FiowLayout.png" alt="布局管理器"></p><p>构造方法:</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>FlowLayout ()</td><td>组件默认居中对齐，水平、垂直间距默认为5个单位。</td></tr><tr><td>FlowLayout (int align)</td><td>指定组件相对于容器的对齐方法，水平、垂直间距默认为5个单位。</td></tr><tr><td>FlowLayout (int align,int hgap,int vgap)</td><td>指定组件的对齐方法和水平、垂直间距。</td></tr></tbody></table><p> <strong>注释:</strong>align的值为LEFT(左对齐)、RIGHT(右对齐)、CENTER(居中对齐)，也可是使用FlowLayout.LEFT等方式进行设置。</p><h4 id="BorderLayout-边界布局管理器"><a href="#BorderLayout-边界布局管理器" class="headerlink" title="BorderLayout (边界布局管理器)"></a>BorderLayout (边界布局管理器)</h4><p><strong>BordeLayout</strong>将容器划分为5个区域，分别是东(EAST)、南(SOUTH)、西(WEST)、北(NORTH)、中(CENTER)，在BordeLayout中添加组件时，需要使用<strong>add (Component comp,Object constraints)</strong>方法添加，其中comp表示要添加的组件，constraints指定将组件添加到布局中的方式和位置的对象。<br><img src="/images/BorderLayout.png" alt="布局管理器"></p><p>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Button but = new Button (&quot;按钮&quot;);</span><br><span class="line">f.add(but,BorderLayout.EAST);</span><br></pre></td></tr></table></figure><p><strong>注释:</strong>一个区域只能添加一个组件，再次添加将覆盖。默认添加位置为中部。</p><h4 id="GridLayout-网格布局管理器"><a href="#GridLayout-网格布局管理器" class="headerlink" title="GridLayout (网格布局管理器)"></a>GridLayout (网格布局管理器)</h4><p><strong>GridLayout</strong>使用纵横线将容器分成n行m列大小相等的网格，每个网格中放置一个组件。特点是组件的相对位置不变，但组件的大小会随窗体对象的改变而改变。<br><img src="/images/GridLayout.png" alt="布局管理器"></p><p>构造方法:</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>GridLayout ()</td><td>默认只有一行，每个组件占一列。</td></tr><tr><td>GridLayout (int rows,int cols)</td><td>指定容器的行数和列数。</td></tr><tr><td>GridLayout (int rows,int clos,int hgap,int vgap)</td><td>指定容器的行数和列数以及组件之间的水平、垂直间距。</td></tr></tbody></table><h4 id="GridBagLayout-网格包布局管理器"><a href="#GridBagLayout-网格包布局管理器" class="headerlink" title="GridBagLayout (网格包布局管理器)"></a>GridBagLayout (网格包布局管理器)</h4><p><strong>GridBagLayout</strong>允许网格中的组件大小各不相同，并且允许一个组件跨过一个或多个网格。<br><img src="/images/GridBagLayout.jpg" alt="布局管理器"></p><p>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//1.创建布局管理器，并使该容器采用该布局管理器</span><br><span class="line">GridBagLayout layout = new GridBagLayout ();</span><br><span class="line">container.setLayout (layout);</span><br><span class="line">//2.创建GridBagContrants对象（布局约束条件），并设置相关属性</span><br><span class="line">GridBagConstraints constraints = new GridBagConstraints ();</span><br><span class="line">constraints.gridx = 1；                                         //设置网格的左上角横向索引</span><br><span class="line">constraints.gridy = 1;                                          //设置网格的左上角纵向索引</span><br><span class="line">constraints.gridwidth = 1;                                      //设置组件横向跨越的网格</span><br><span class="line">constraints.gridheigh = 1;                                      //设置组件纵向跨越的网格</span><br><span class="line">//3.建立对象和受控组件之间的关系</span><br><span class="line">layout.serConstraints(component,constraints);</span><br><span class="line">//4.向容器中添加组件</span><br><span class="line">container.add(component);</span><br></pre></td></tr></table></figure><p><strong>注释:</strong>若想添加其他组件并改变它的属性，只需要修改2、3、4步即可。<br>常用属性：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>gridx和gridy</td><td>设置索引。若将其设置为 RELATIVE（默认值），表示当前组件紧跟着上一个组件。</td></tr><tr><td>gridwidth和gridheigh</td><td>设置跨越的网格数，默认为1.将其设置为REMAINER,表示为在其行或列上为最后一个组件。若设置为RELATIVE表示为倒数第2个组件。</td></tr><tr><td>fill</td><td>NONE:默认，不改变组件大小。HORIZONTAL:使组件水平方向足够长以填充区域，但高度不变。VERTICAL:使组件垂直方向足够高以填充区域，但长度不变。BOTH:使组件足够大，填充整个显示区域。</td></tr><tr><td>weightx和weighty</td><td>设置组件占容器中多余的空白比例。</td></tr></tbody></table><h4 id="CardLayout-卡片布局管理器"><a href="#CardLayout-卡片布局管理器" class="headerlink" title="CardLayout (卡片布局管理器)"></a>CardLayout (卡片布局管理器)</h4><p><strong>CardLayout</strong>使用按钮切换卡片。</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>void first(Container parent)</td><td>显示容器的第一张卡片。</td></tr><tr><td>void last(Container parent)</td><td>显示容器的最后一张卡片。</td></tr><tr><td>void previous(Container parent)</td><td>显示容器的前一张卡片。</td></tr><tr><td>void next(Container parent)</td><td>显示容器的后一张卡片。</td></tr><tr><td>void show（Container parent，String name)</td><td>显示容器中名称为name的组件，若不存在，则不会发生操作。</td></tr></tbody></table><h4 id="无主题模式"><a href="#无主题模式" class="headerlink" title="无主题模式"></a>无主题模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame.setLayout(null);                                         //将主题设置为空</span><br><span class="line">but.setBounds (40, 60, 100, 30);                               //设置按钮的大小，位置</span><br></pre></td></tr></table></figure><h3 id="AWT事件处理"><a href="#AWT事件处理" class="headerlink" title="AWT事件处理"></a>AWT事件处理</h3><blockquote><p>事件处理机制就是专门响应用户的操作</p></blockquote><p><strong>事件对象:</strong>封装上GUI组件上发生的特定事件（指用户的一次操作）。<br><strong>事件源（组件）:</strong>事件发生的场所，通常就是产生事件的组件。<br><strong>监听器（Listener）:</strong>负责监听事件源上发生的事件，并对各种事件做出相应处理的对象。<br><strong>事件处理器:</strong>监听器对象对接受的事件对象进行相应处理的方法。</p><h4 id="事件适配器"><a href="#事件适配器" class="headerlink" title="事件适配器"></a>事件适配器</h4><p>JDK中提供的类，用于设置接口中的方法，但默认的方法都为空，需要使用哪个就修改那个。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//窗口关闭按钮</span><br><span class="line">f.addWindowListener (new MyWindowListener());</span><br><span class="line"></span><br><span class="line">class MyWindowListener extends WindowAdapter &#123;</span><br><span class="line">    public void windowClosing (WindowEvent e) &#123;</span><br><span class="line">       Window window = (Window) e.getComponent ();</span><br><span class="line">       window.dospose ();</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>在Java中，便于程序代码的简洁，便使用匿名内部类。</p><p>代码示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Button but = new Button (&quot;EXIT&quot;);</span><br><span class="line">but.addMouseListener (new MouseListener () &#123;</span><br><span class="line">    public void mouseClicked (MouseEvent e)&#123;</span><br><span class="line">        System.exit(0);</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="常用事件分类"><a href="#常用事件分类" class="headerlink" title="常用事件分类"></a>常用事件分类</h3><p>1.AWT中提供了大量的事件，大致可分为窗口事件(WindowEvent)、鼠标事件(MouseEvent)、键盘事件(KeyEvent)、动作事件(ActionEvent)。<br>2.每个事件都有其JDK提供的类，例如:WindowEvent。并且还提供了一个接口和类便于功能的实现,例如:WindowListener(接口)、WindowAdapter(类)。</p><h2 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h2><blockquote><p><strong>Swing</strong>是基于Java语言编写成的，其组件不依赖于平台，并把其称为轻量级组件。</p></blockquote><p><img src="/images/Swing.jpg" alt="Swing"></p><h3 id="JFrame"><a href="#JFrame" class="headerlink" title="JFrame"></a>JFrame</h3><p>1.JFrame与Frame一样，都是独立存在的顶级窗口，其使用方法也与Frame大体一致。<br>2.JFrame类提供了关闭窗口的功能，只需要调用<strong>setDefaultCloseOperation()</strong>方法，将<strong>JFrame.EXIT_ON_CLOSE</strong>作为参数导入即可。</p><h3 id="JDialog"><a href="#JDialog" class="headerlink" title="JDialog"></a>JDialog</h3><p>1.JDialog是Swing的另一个顶级窗口，即对话框。<br>2.对话框可分为两种：模态对话框和非模态对话框。<br>3.模态对话框：指用户必须处理完该对话框的内容后才能与其他窗口交互。<br>4.非模态对话框：指允许用户在处理对话框的同时与其他窗口交互。</p><p>构造方法：</p><table><thead><tr><th>方法描述</th><th>功能声明</th></tr></thead><tbody><tr><td>JDialog (Frame owner)</td><td>创建一个非模态对话框，owner为对话框的所有者。</td></tr><tr><td>JDialog (Frame owner,String title)</td><td>创建一个具有指定标题的非模态对话框。</td></tr><tr><td>JDialog (Frame owner,boolean modal)</td><td>创建一个有指定模式的无标题对话框，模态为true，默认为非模态false。</td></tr></tbody></table><h3 id="中间容器"><a href="#中间容器" class="headerlink" title="中间容器"></a>中间容器</h3><p>Swing不仅具有JFrame和JFialog这样的顶级容器，还提供了一些中间容器，这些容器不能单独存在，只能放置在顶级窗口中，分别有JPanle和JScrollPane。<br>1.JPanle：与AWT中的Panle使用方法基本一致，它是一个无边框，不能被移动、放大、缩小或关闭的面板。<br>2.JScrollPane：其是一个带有滚动条的面板容器，而且只能添加一个组件。<br>3.若想在JScrollPane中添加多个组件，首先向JPanle中天健多个组件，在将JPanle添加到JScrollPane中。</p><p>JScrollPane构造方法：</p><table><thead><tr><th>方法描述</th><th>功能声明</th></tr></thead><tbody><tr><td>JScrollPane ()</td><td>创建一个空的面板。</td></tr><tr><td>JScrollPane (Component view)</td><td>创建一个显示指定组件的面板，若组件内容超过视图大小就会显示滚动条。</td></tr><tr><td>JScrollPane (Component view,int vsbPolicy,int hsbPolicy)</td><td>创建一个显示指定容器并具有指定滚动策略的面板。vsbPolicy和hsbPolicy分别为垂直和水平滚动策略。</td></tr></tbody></table><p><strong>注释：</strong>以下为第三个构造函数的参数<br>1.HORIZONTAL_SCROLLBAR_AS_NEEDED:表示水平滚动条只在需要时显示，默认策略。<br>2.HORIZONTAL_SCROLLBAR_NEVER:表示水平滚动条永远不显示。<br>3.HORIZONTAL_SCROLLBAR_ALWAYS:表示水平滚动条一直显示。</p><p>JScrollPane方法：</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>void setHorizontalBarPolicy (int policy)</td><td>指定水平滚动策略，即滚动条何时出现在滚动面板上。</td></tr><tr><td>void setVerticalBarPolicy (int policy)</td><td>指定垂直滚动策略，即滚动条何时出现在滚动面板上。</td></tr><tr><td>void setViewportView (Component view)</td><td>设置在滚动面板显示的组件。</td></tr></tbody></table><h3 id="文本组件"><a href="#文本组件" class="headerlink" title="文本组件"></a>文本组件</h3><p><strong>文本组件</strong>用于接收用户输入的信息或向用户展示信息。其中包括文本框（JtextField）、文本域（JtextArea）等，他们都有一个共同父类JTextComponent。</p><p>JTextComponent常用方法：</p><table><thead><tr><th>方法描述</th><th>功能声明</th></tr></thead><tbody><tr><td>String getText ()</td><td>返回文本组件中所有的内容文本。</td></tr><tr><td>String getSelectedText ()</td><td>返回文本组件中选定的文本内容。</td></tr><tr><td>void selecttAll ()</td><td>在文本组件中选中所有内容。</td></tr><tr><td>void setEditable ()</td><td>设置文本组件为可编辑或者不可编辑状态。</td></tr><tr><td>void setText (String text)</td><td>设置文本组件的内容。</td></tr><tr><td>void replaceSelection (String content)</td><td>用给定的内容替换当前选定的内容。</td></tr></tbody></table><h4 id="JTextField"><a href="#JTextField" class="headerlink" title="JTextField"></a>JTextField</h4><p><strong>JTextField:</strong>称为文本框，它只能接收单行文本的输入。</p><p>构造方法：</p><table><thead><tr><th>方法描述</th><th>功能声明</th></tr></thead><tbody><tr><td>JTextField ()</td><td>创建一个空的文本框，初始字符串为null。</td></tr><tr><td>JTextField (int columns)</td><td>创建一个具有指定列数的文本框，初始字符串为null。</td></tr><tr><td>JTextField (String text)</td><td>创建一个显示指定初始字符串的文本框。</td></tr><tr><td>JTextField (String text,int column)</td><td>创建一个具有指定列数并显示指定初始字符串的文本框。</td></tr></tbody></table><h4 id="JTextArea"><a href="#JTextArea" class="headerlink" title="JTextArea"></a>JTextArea</h4><p><strong>JTextArea:</strong>称为文本域，他能接收多行文本的输入。</p><p>构造方法：</p><table><thead><tr><th>方法描述</th><th>功能声明</th></tr></thead><tbody><tr><td>JTextArea ()</td><td>创建一个空的文本域。</td></tr><tr><td>JTextArea (String text)</td><td>创建显示指定初始字符串的文本域。</td></tr><tr><td>JTextArea (int rows,int columns)</td><td>创建具有指定行和列的空文本域。</td></tr><tr><td>JTextArea (String text,int rows,int columns)</td><td>创建显示指定初始文本并指定了行列的文本域。</td></tr></tbody></table><h3 id="按钮组件"><a href="#按钮组件" class="headerlink" title="按钮组件"></a>按钮组件</h3><p>常见的按钮组件有JButton、JCheckBox、JRedioButton等，他们都是ABstractButton类的直接或间接子类。</p><p>ABstractButton类常用方法：</p><table><thead><tr><th>方法描述</th><th>功能声明</th></tr></thead><tbody><tr><td>locn getlcon ()和void setlcon (lcon icon)</td><td>设置或者获取按钮的图标。</td></tr><tr><td>String getText ()和void setText （String text）</td><td>设置或者获取按钮的文本。</td></tr><tr><td>void setEnable (boolean b)</td><td>启用（当b为true）或禁用（当b为false）按钮。</td></tr><tr><td>setSelected (boolean b)</td><td>设置按钮的状态，当b为true时为选中状态，反正为未选中。</td></tr><tr><td>boolean isSelected()</td><td>返回按钮的状态（true为选中，反之为未选中）。</td></tr></tbody></table><h4 id="JButton"><a href="#JButton" class="headerlink" title="JButton"></a>JButton</h4><p>JButton只是一个简单的按钮，可以对其按钮的功能进行私人订制。</p><h4 id="JCheckBox"><a href="#JCheckBox" class="headerlink" title="JCheckBox"></a>JCheckBox</h4><p><strong>JCheckBox组件</strong>被称为复选框，有选中（是）和未选中（非）两种状态。</p><p>构造方法：</p><table><thead><tr><th>方法描述</th><th>功能声明</th></tr></thead><tbody><tr><td>JCheckBox ()</td><td>创建一个没有文本信息，初始状态未被选中的复选框。</td></tr><tr><td>JCheckBox (String text)</td><td>创建一个带有文本信息，初始状态未被选中的复选框。</td></tr><tr><td>JCheckBox (String text,boolean select)</td><td>创建一个带有文本信息，并指定初始状态的复选框。</td></tr></tbody></table><h4 id="JRadionButton"><a href="#JRadionButton" class="headerlink" title="JRadionButton"></a>JRadionButton</h4><p><strong>JRadionButton组件</strong>被称为单选按钮，单选按钮为只能选中一个。</p><p>构造方法：</p><table><thead><tr><th>方法描述</th><th>功能声明</th></tr></thead><tbody><tr><td>JRadioButton ()</td><td>创建一个没有文本信息，初始状态未被选中的单选框。</td></tr><tr><td>JRadioButton (String text)</td><td>创建一个带有文本信息，初始状态未被选中的单选框。</td></tr><tr><td>JRadioButton (String text,boolean selected)</td><td>创建一个带有文本信息，并指定初始状态的单选框。</td></tr></tbody></table><h4 id="JComboBox"><a href="#JComboBox" class="headerlink" title="JComboBox"></a>JComboBox</h4><p><strong>JComboBox组件</strong>被称为组合框或下拉列表框，它将所有的选项折叠收藏在一起，默认显示的是第一个添加的选项。<br>1.JComboBox组合框可分为可编辑和不可编辑两种形式。<br>2.可编辑组合框用户自己输入的新内容不会添加到组合框的选项列表中。</p><p>构造方法：</p><table><thead><tr><th>方法描述</th><th>功能声明</th></tr></thead><tbody><tr><td>JComboBox ()</td><td>创建一个没有可选项的组合框。</td></tr><tr><td>JComboBox ()</td><td>创建一个组合框，将Object数组中的元素作为组合框的下拉列表选项。</td></tr><tr><td>JComboBox ()</td><td>创建一个组合框，将Vector集合中的元素作为组合框的下拉列表选项。</td></tr></tbody></table><p>常用方法：</p><table><thead><tr><th>方法描述</th><th>功能声明</th></tr></thead><tbody><tr><td>void addltem (Object anObject)</td><td>为组合框添加选项。</td></tr><tr><td>void insertltemAt (Object anObject,int insex)</td><td>在指定的索引处插入选项。</td></tr><tr><td>Object getltemAt (int index)</td><td>返回指定索引处的选项，第一个选项的索引值为0。</td></tr><tr><td>int getltemCount ()</td><td>返回组合框中选项的数目。</td></tr><tr><td>Object getSelectedltem ()</td><td>返回当前选项。</td></tr><tr><td>void removeAllltems ()</td><td>删除组合框中的所有选项。</td></tr><tr><td>void removeltem (Object object)</td><td>从组合框中删除指定选项。</td></tr><tr><td>void removeltemAt (int index)</td><td>移除指定索引处的选项。</td></tr><tr><td>void serEditable (boolean aFlag)</td><td>设置组合框的选项是否可编辑，true为可编辑。</td></tr></tbody></table><h3 id="菜单组件"><a href="#菜单组件" class="headerlink" title="菜单组件"></a>菜单组件</h3><p>菜单组件就是一个程序的菜单栏。</p><h4 id="下拉式菜单"><a href="#下拉式菜单" class="headerlink" title="下拉式菜单"></a>下拉式菜单</h4><p>创建和添加下拉式菜单可分为：<br>1.创建一个JMenuBar菜单栏对象，将其放在窗口顶部。<br>2.创建JMenu菜单对象，将其天健到JMenuBar菜单栏中。<br>3.创建JMenultem菜单项，将其添加到JMenu菜单中。</p><h5 id="JMenuBar-菜单栏"><a href="#JMenuBar-菜单栏" class="headerlink" title="JMenuBar(菜单栏)"></a>JMenuBar(菜单栏)</h5><p><strong>JMenuBar:</strong>表示一个水平的菜单栏，用于管理菜单，不参与同同用户的交互式操作。<br>1.菜单栏可以放在容器的任何位置。<br>2.通常使用顶级窗口的<strong>setJMenuBar (JMenuBar menBar)</strong>方法放在顶级窗口的顶部。</p><h5 id="JMenu-菜单"><a href="#JMenu-菜单" class="headerlink" title="JMenu(菜单)"></a>JMenu(菜单)</h5><p><strong>JMenu:</strong>用于整合管理菜单项。<br>1.可以使用<strong>add (JMenu c)</strong>方法将菜单添加到菜单栏中。<br>2.构造方法：<strong>JMenu (String text)</strong>。</p><p>常用方法:</p><table><thead><tr><th>方法描述</th><th>功能声明</th></tr></thead><tbody><tr><td>void JMenultem add (JMenultem menultem)</td><td>将菜单项添加到菜单末尾，返回此菜单项。</td></tr><tr><td>void addSeparator ()</td><td>将分隔符添加到菜单的末尾。</td></tr><tr><td>JMenultem getltem (int pos)</td><td>返回指定索引处的菜单项。</td></tr><tr><td>int getltemCount()</td><td>返回菜单上的系数，菜单项和分隔符都计算在内。</td></tr><tr><td>void JMenultem insert ()</td><td>在指定索引处插入菜单项。</td></tr><tr><td>void insertSeparator (int pos)</td><td>在指定索引处插入分隔符。</td></tr><tr><td>void renove (int pos)</td><td>从菜单中移除指定索引处的菜单项。</td></tr><tr><td>void remove (JMenultem menultem)</td><td>从菜单中移除指定的菜单项。</td></tr><tr><td>void removeAll ()</td><td>从菜单中移除所有的菜单项。</td></tr></tbody></table><h5 id="JMenultem-菜单项"><a href="#JMenultem-菜单项" class="headerlink" title="JMenultem(菜单项)"></a>JMenultem(菜单项)</h5><p>1.<strong>JMenultem类</strong>继承ABstractButton类，可以将其看成一个按钮。<br>2.构造方法:<strong>JMenultem (String text)</strong>.</p><h4 id="弹出式菜单"><a href="#弹出式菜单" class="headerlink" title="弹出式菜单"></a>弹出式菜单</h4><p>1.<strong>JPopopMenu</strong>弹出式菜单，使用add（）方法为其添加JMenultem菜单项。<br>2.弹出式菜单默认是不显示的，需要使用<strong>show (Compoent invoker,int x,int y)</strong>方法显示。<br>2.弹出式菜单就是鼠标右键单击后弹出的菜单。</p><p>弹出式菜单代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this.addMouseListener (new MouseAdpter ()&#123;</span><br><span class="line">    public void mouseClicked (MouseEvent e)&#123;</span><br><span class="line">       if (e.getButton()==e.BUTTON3)&#123;</span><br><span class="line">           弹出式菜单.show (e.getComponent(),e.getX(),e.getY());</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java一IO</title>
      <link href="/2019/11/01/Java%E4%B8%80IO/"/>
      <url>/2019/11/01/Java%E4%B8%80IO/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>IO（输入输出）流</strong>：主要实现程序和硬盘之间的数据交换，其最主要的分类是按照操作数据的不同，可以分为字节流和字符流。</p></blockquote><p><img src="/images/io.jpg" alt="IO流"></p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><blockquote><p>在计算机中，所有的文件都是以二进制（字节）形式存在的，在Java中针对字节的输入输出提供的一系列流，称为字节流。字节流按照传输方向，可以分为字节输入流(InputStream)和字节输出流(OutputStream)。在JDK中提供了俩个抽象类，是字节流的父类。</p></blockquote><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><blockquote><p><strong>InputStream</strong>一般作用于将硬件设备中的数据传输到程序中。 </p></blockquote><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>int read()</td><td>在输入流读取一个8位数的字节，将它转换成十进制并返回。</td></tr><tr><td>int read(byte[] b)</td><td>在输入流中读取若干字节，将它保存在b数组中，返回的整数表示读取的字节的数目。</td></tr><tr><td>int read(byte [] b,int off,int len)</td><td>在输入流中读取若干字节，保存到b数组中，off指定数组中保存的位置，len表示读取的字节数目。</td></tr><tr><td>void close()</td><td>关闭输入流且释放与之相关的资源。</td></tr></tbody></table><h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><blockquote><p><strong>OutputStream</strong>用作于将程序的数据传输到目标设备中。</p></blockquote><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>void write(int b)</td><td>向输出流写入一个字节。</td></tr><tr><td>void write(byte [] b)</td><td>把b数组中的所有字节写到输出流。</td></tr><tr><td>void write(byte [] b,int off,int  len)</td><td>将指定数组的从off开始到len的字节写到输出流。</td></tr><tr><td>void flush()</td><td>刷新此输出流并强制写出所有缓冲的输出字节。</td></tr><tr><td>void close</td><td>关闭输出流并释放与之相关的资源。</td></tr></tbody></table><h3 id="字节流读写文件"><a href="#字节流读写文件" class="headerlink" title="字节流读写文件"></a>字节流读写文件</h3><blockquote><p>字节流的读写分别是<strong>FileInputStream</strong>类和<strong>FileOutputStream</strong>类,而他俩分别是InoutStream和OutputStream的子类，</p></blockquote><p>FileInputStream主要用于读取文件中的数据。<br>代码及使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInStream in = new FileInputStream (&quot;文件名.文件类型&quot;)；</span><br><span class="line">//在文件的读取过程中，当一个字节读取为-1时，则表示文件结束</span><br></pre></td></tr></table></figure><p>FileOutputStream主要用于把数据写入文件中。<br>代码及使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在执行过程中，优先创建文件，若有该文件则先清空文件数据，在重新写入数</span><br><span class="line">FileOutputStream out = new FileOutputStream (&quot;文件名.文件类型&quot;);</span><br><span class="line"></span><br><span class="line">//若文件已存在，则在文件末尾添加数据</span><br><span class="line">FileOutputStream out = new FileOutputStream (&quot;文件名.文件类型&quot;,true);</span><br></pre></td></tr></table></figure><h4 id="文件的拷贝"><a href="#文件的拷贝" class="headerlink" title="文件的拷贝"></a>文件的拷贝</h4><p>文件的拷贝采用的<strong>void read（）</strong>方法，但一次只能操作一个字节的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//在使用两个函数时，默认打开的都是项目下的根文件夹</span><br><span class="line">FileInputStream in = new FileInputStream (&quot;文件夹1//文件名.文件类型&quot;)；</span><br><span class="line">FileOutputStream out = new FileOutputStream (&quot;文件夹2//文件名.文件类型&quot;);</span><br><span class="line">int len;</span><br><span class="line">while(len=in.read()!=-1)&#123;</span><br><span class="line">   out.write(len);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="字符流的缓冲区"><a href="#字符流的缓冲区" class="headerlink" title="字符流的缓冲区"></a>字符流的缓冲区</h4><p>字符流的缓冲区采用的是 <strong>void rean(byte[] b)</strong>方法，比单纯的使用void read（）方法要快很多，但是需要在内存中分配空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream in = new FileInputStream (&quot;文件夹1//文件名.文件类型&quot;);</span><br><span class="line">FileOutputStream out = new FileOutputStream (&quot;文件夹2//文件名.文件类型&quot;);</span><br><span class="line">byte [] buff =new byte [1024];        //定义一个字符数组，作为缓冲区</span><br><span class="line">int len;</span><br><span class="line">while((len=in.read(buff))!=-1)&#123;</span><br><span class="line">   out.write(buff,0,len);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><p><strong>BufferInputStream</strong>类和<strong>BufferOutputStream</strong>类分别为FileInputStream和FileOutputStream的子类，作用是在读写文件时提供一个8192字节的缓冲区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BufferInputStream in = new BufferInputStream ( new FileInputStream (&quot;文件名1.文件类型&quot;));</span><br><span class="line">BufferInputStream out = new BufferInputStream ( new FileOutputStream (&quot;文件名2.文件类型&quot;));</span><br><span class="line">int len;</span><br><span class="line">while(len=in.read()!=-1)&#123;</span><br><span class="line">   out.write(len);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><blockquote><p>在Java编译器中，由于在程序中操作的都是字符，所以提供了字符流的JDK。其包括两个顶级父类，分别为<strong>Reader</strong>和<strong>Writer</strong>。</p></blockquote><h3 id="字符流操作文件"><a href="#字符流操作文件" class="headerlink" title="字符流操作文件"></a>字符流操作文件</h3><h4 id="字符操作流"><a href="#字符操作流" class="headerlink" title="字符操作流"></a>字符操作流</h4><p>对于文本文件的操作方式可以使用<strong>FileReader（字符输入流）</strong>和<strong>FileWriter（字符输出流）</strong>两种方式进行操作，其使用方法与InputStream和OutputStream基本一致。</p><p>区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileReader re = new FileReader (文件名.文件类型);</span><br><span class="line">int in;</span><br><span class="line">in = re.read();</span><br><span class="line">//在FileReader中的read（）函数返回的是int类型的值，若想使用可以将其转换为char型</span><br><span class="line">char ch = （char）in；</span><br></pre></td></tr></table></figure><h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><p>1.字符缓冲流分别为<strong>BufferedReader</strong>和<strong>BufferedWriter</strong>两种，使用方法与字节缓冲流一致。<br>2.在字符缓冲流中的BufferedReader提供了一个重要函数，为<strong>readLine()</strong>,该方法用于一次读取一行文本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建一个FileReader输入流对象，并为其分配缓冲区</span><br><span class="line">FileReader re = new FileReader (&quot;文本1.txt&quot;);</span><br><span class="line">BufferedReader br = new BufferedReader (re);</span><br><span class="line">//创建一个FileWriter输出流对象，并为其分配缓冲区</span><br><span class="line">FileWriter wr = new FileWriter (&quot;文本2.txt&quot;);</span><br><span class="line">BufferedWriter bw = new BufferedWriter (wr);</span><br><span class="line">String str;</span><br><span class="line">while ((str = br.readLine()) != null)&#123;</span><br><span class="line">   bw.write(str);</span><br><span class="line">   bw.newLine();       //为文本2输出一个换行</span><br><span class="line">   &#125;</span><br><span class="line">br.close();</span><br><span class="line">bw.close();</span><br><span class="line">//在使用字符缓冲流时，使用Write（）函数时，字符会先被写入缓冲区，只有当缓冲区写满或者执行close（）时，字符才会写入目标文件</span><br></pre></td></tr></table></figure><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>在Java中，IO流可以分为字节流和字符流，有时也需要进行转换。JDK提供了两个类，可以将字节流转换为字符流，为<strong>InputStreamReader</strong>和<strong>OutputStreamWriter</strong>。<br>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream in = new FileInputStream (&quot;文本.txt&quot;);</span><br><span class="line">FileOutputStream out = new FileOutputStream (&quot;文本.txt&quot;,true);</span><br><span class="line">InputStreamReader ir = new InputStreamReader(in);</span><br><span class="line">OutputStreamWriter ow = new OutputStreamWriter (out);</span><br><span class="line">//在使用转换流时，只能针对文本文件进行转换</span><br></pre></td></tr></table></figure><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><blockquote><p>前面的IO流只是针对文件的内容进行读写，而有时也需要对文件进行操作。JDK提供类一个<strong>File</strong>类，用于对文件进行操作。<strong>File类</strong>用于封装一个路径，并且提供了一系列的方法用于操作该路径指向的文件。</p></blockquote><h3 id="File类常用方法"><a href="#File类常用方法" class="headerlink" title="File类常用方法"></a>File类常用方法</h3><p>构造方法：</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>File(String pathname)</td><td>通过指定的一个字符串类型的文件路径来创建一个新的File对象。</td></tr><tr><td>File(String parent,String child)</td><td>根据指定父类路径和指定的子路径来创建一个File对象。</td></tr><tr><td>File(File parent,String child)</td><td>根据指定的File类型的父类路径和字符串的子路径来创建一个File对象。</td></tr></tbody></table><p><strong>注释</strong>:如果程序只处理一个目录或文件，并且知道该目录或文件路径，使用第一个构造方法。  反之若处理一个公共目录中的若干子目录或文件，则使用第二个或第三个构造方法。</p><p>常用方法：</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>boolean exists()</td><td>判断目标文件或目录是否存在。</td></tr><tr><td>boolean delete()</td><td>删除目标文件或目录。</td></tr><tr><td>boolean creatNewFile()</td><td>若目标文件不存在，则创建一个新文件。</td></tr><tr><td>boolean makdir()</td><td>创建一个文件夹。</td></tr><tr><td>boolean makdirs()</td><td>创建一个文件夹。若父类文件夹不存在也将创建。</td></tr><tr><td>String getName()</td><td>返回目标文件或文件夹的名称。</td></tr><tr><td>String getPath()</td><td>返回File对象的路径。</td></tr><tr><td>String getAbsolutePath()</td><td>返回File对象的绝对路径。</td></tr><tr><td>String getParent()</td><td>返回File对象对应目录的父目录。</td></tr><tr><td>boolean canRead()</td><td>判断目标文件或目录是否可读。</td></tr><tr><td>boolean canWrite()</td><td>判断目标文件或目录是否可写。</td></tr><tr><td>boolean isFile()</td><td>判断目标是否是文件。</td></tr><tr><td>boolean isDirectory()</td><td>判断目标是否是目录。</td></tr><tr><td>boolean isAbsolute()</td><td>判断目标文件或目录是否为绝对路径。</td></tr><tr><td>long lastModified()</td><td>返回1970.1.1 0:00到文件修改时间的毫秒值。</td></tr><tr><td>long length()</td><td>返回文件内容长度。</td></tr><tr><td>String [] list()</td><td>列出指定目录的全部内容，只列出名称。</td></tr><tr><td>File [] listFiles()</td><td>返回一个包含了File对象所有文件和子目录的File数组。</td></tr></tbody></table><h3 id="文件夹下的遍历"><a href="#文件夹下的遍历" class="headerlink" title="文件夹下的遍历"></a>文件夹下的遍历</h3><h4 id="文件名遍历"><a href="#文件名遍历" class="headerlink" title="文件名遍历"></a>文件名遍历</h4><p>1.遍历目录下的所有文件的文件名，可以使用<strong>list()</strong>函数。<br>2.若想要遍历指定类型的文件，则需要使用<strong>list(FilenameFilter filter)</strong>方法。<br>3.<strong>FilenameFilter（文件过滤器）</strong>是一个接口，其中定义了一个抽象方法<strong>accept(File dir,String name)</strong>。<br>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;D:\\chesshi\\java&quot;);</span><br><span class="line">//创建过滤器对象</span><br><span class="line">FilenameFilter filter = new FilenameFilter ()&#123;</span><br><span class="line">    public boolean accept ( File dir , String name )&#123;</span><br><span class="line">        File currFile = new File (dir, name);</span><br><span class="line">if (currFile.isFile()&amp;&amp;name.endsWith(&quot;.txt&quot;))&#123;</span><br><span class="line">    return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//循环输出目标文件名</span><br><span class="line">if (file.exists()) &#123;</span><br><span class="line">    String [] lists = file.list(filter);   //获取过滤后的数组值</span><br><span class="line">    for (String name : lists)&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子目录遍历"><a href="#子目录遍历" class="headerlink" title="子目录遍历"></a>子目录遍历</h4><p>1.子目录的遍历使用<strong>listFile()</strong>方法。<br>2.有时子目录下还有目录，则需要使用递归遍历。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void fileDir(File dir)&#123;</span><br><span class="line">    File[] files = dir.listFiles();</span><br><span class="line">    for(File file : files)&#123;</span><br><span class="line">        if(file.isDirectory())&#123;</span><br><span class="line">     fileDir(file);</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除文件或目录"><a href="#删除文件或目录" class="headerlink" title="删除文件或目录"></a>删除文件或目录</h3><p>1.文件或目录的删除只需要使用<strong>delete（）</strong>方法。<br>2.若目录下还有子目录，则需要使用递归删除。<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void deleteDir(File dir)&#123;</span><br><span class="line">   if (dir.exists()) &#123;                    //判断File对象是否存在</span><br><span class="line">       File [] files = dir.listFiles();</span><br><span class="line">       for (File file : files) &#123;</span><br><span class="line">           if (file.isDirectory())&#123;</span><br><span class="line">        delectDir(file);          //如果是目录，则递归</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">         //如果是文件，直接删除</span><br><span class="line">         file.delect();</span><br><span class="line">   &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //删除完一个目录里的所有文件，就删除这个目录</span><br><span class="line">       dir.delect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java一集合类</title>
      <link href="/2019/10/22/Java%E4%B8%80%E9%9B%86%E5%90%88%E7%B1%BB/"/>
      <url>/2019/10/22/Java%E4%B8%80%E9%9B%86%E5%90%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在程序中可以用数组来保存多个对象，但在某些情况下无法确定保存对象的个数，此时则需要以集合的形式进行数据保存。在Java程序中，可以存储任何类型的对象，且长度可以改变，这种类统称为<strong>集合</strong>。集合按照存储结构可以分为两大类，即单列集合<strong>Collection</strong>和双列集合<strong>Map</strong>。</p></blockquote><p><img src="/images/%E9%9B%86%E5%90%88%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="集合关系图"></p><h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><blockquote><p><strong>Collection</strong>:单列集合类的根接口，用于存储一系列复合某种规则的元素，有两个重要的子接口，分别为List和Set。 <strong>Collection</strong>接口是所有单列集合的父接口。</p></blockquote><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>boolean add(Object o)</td><td>向集合中添加一个元素</td></tr><tr><td>boolean addAll（Collection c）</td><td>将指定Collection中的所有元素添加到该集合中。</td></tr><tr><td>void clear()</td><td>删除指定集合中的所有元素。</td></tr><tr><td>boolean remove（Object o）</td><td>删除集合中的指定元素。</td></tr><tr><td>boolean removeAll（Collection c）</td><td>删除指定集合中的所有元素。</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空。</td></tr><tr><td>boolean contains(Object o)</td><td>判断该集合中是否包含某个元素。</td></tr><tr><td>boolean containsAll(Collection c)</td><td>判断该集合中是否包含指定集合中的所有元素。</td></tr><tr><td>Iterator iterator()</td><td>返回在该集合的元素上进行迭代器，用于遍历该集合的所有元素。</td></tr><tr><td>int size()</td><td>获取该集合元素的个数。</td></tr><tr><td>Collections.sort(Lise list)</td><td>按照字母进行排序</td></tr></tbody></table><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><blockquote><p><strong>List</strong>接口继承自Collection接口，其特点是元素有序，可重复。存储方式 是元素以一种线性方式进行存储。List接口的主要实现类有<strong>ArrayList</strong>和<strong>LinkedList</strong>。</p></blockquote><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>void add（int index,Object element）</td><td>将元素插入指定位置中。</td></tr><tr><td>boolean addAll(int index,Collection c)</td><td>将集合插入指定位置中</td></tr><tr><td>Object get(int index)</td><td>返回集合索引处的index元素</td></tr><tr><td>Object remove(int index)</td><td>删除index索引处的元素</td></tr><tr><td>Object set(int inndex,Object element)</td><td>替换指定位置的元素。</td></tr><tr><td>int indexOf(Object o)</td><td>返回对象o处的位置索引。</td></tr><tr><td>int lastIndexOf(Object o)</td><td>返回对象o在集合中最后一次出现的位置索引。</td></tr><tr><td>List subList(int fromIndex,int toIndex)</td><td>将指定起始位置生成一个集合。</td></tr></tbody></table><h4 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h4><blockquote><p><strong>ArrayList</strong>是List接口的一个实现类，ArrayList集合中存放着一个可以改变大小的数组，且ArrayList集合更适用于元素的查找。</p></blockquote><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>void add ();</td><td>添加一个元素</td></tr><tr><td>void remove (int a)</td><td>删除指定位置的元素</td></tr><tr><td>void set (int a, object o)</td><td>修改指定位置的元素</td></tr></tbody></table><p><strong>ArrayList遍历</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//第一种遍历，for方法</span><br><span class="line"> for(int i=0;i&lt; arr.size();i++)&#123;</span><br><span class="line">       System.out.println(arr.get(i)); </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">//第二种遍历 ，for each方法</span><br><span class="line">for (String str:arr) &#123;</span><br><span class="line">      System.out.println(str);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">//第三种遍历 Iterator迭代器</span><br><span class="line">Iterator iterator=arr.iterator();</span><br><span class="line">   while(iterator.hasNext())&#123;</span><br><span class="line">      System.out.println(iterator.next());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h4><blockquote><p><strong>LinkedList</strong>集合内部存放着一个双向循环链表，所以跟适合元素的添加和删除。</p></blockquote><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>void addFirst(Object o)</td><td>将指定元素插入到列表的开头。</td></tr><tr><td>void addLast(Object o)</td><td>将指定元素插入到列表的结尾。</td></tr><tr><td>Object getFirst()</td><td>返回此列表的第一个元素。</td></tr><tr><td>Object getLast()</td><td>返回此列表的最后一个元素。</td></tr><tr><td>Object removeFirst()</td><td>移除列表的第一个元素。</td></tr><tr><td>Object removeLast()</td><td>移除列表的最后一个元素</td></tr></tbody></table><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><blockquote><p><strong>Set</strong>接口继承自Collection接口，比Collection接口更严格。其特点是元素无序，并且会以某种规则以确保元素不可重复。Set接口有两个实现类，分别为<strong>HashSet</strong>和<strong>TreeSet</strong>。</p></blockquote><h4 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h4><blockquote><p><strong>HashSet</strong>是Set的一个实现类，特点是元素无序，元素不可重复。</p></blockquote><p><img src="/images/HashSet.png" alt="HsahSet"></p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>hashCode()</td><td>计算哈希值并确定元素的存储位置</td></tr><tr><td>equals（）</td><td>若确定哈希值相同，则调用该方法来确保没有重复元素。</td></tr></tbody></table><p><strong>HashSet遍历</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//第一种遍历 for-each方法</span><br><span class="line">for(String str:hashset)&#123;</span><br><span class="line">      System.out.println(str);</span><br><span class="line">   &#125;</span><br><span class="line">//第二种 Iterator迭代器遍历</span><br><span class="line">   Iterator&lt;String&gt; iterator=hashset.iterator();</span><br><span class="line">   while(iterator.hasNext())&#123;</span><br><span class="line">      System.out.println(iterator.next());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><blockquote><p><strong>Map</strong>:双列集合类的根接口，用于存储具有键（Key）、值（Value）映射关系的元素，每个元素都包含一对键值，使用Key可以找到相应的Value值。</p></blockquote><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>void put(Object key,Object value)</td><td>将指定的值与指定的键关联(可选操作)。</td></tr><tr><td>Object get(Object key)</td><td>返回指定键所映射的值，如果不包含映射关系则返回null。</td></tr><tr><td>void remove (Object key)</td><td>删除指定键的元素</td></tr><tr><td>boolean containKey(Object key)</td><td>如果此映射包含指定键的映射关系，返回true。</td></tr><tr><td>boolean containValue(Object Value)</td><td>如果此映射将一个或多个键映射到指定值，则返回true。</td></tr><tr><td>Set KeySet()</td><td>返回此映射中包含键的Set视图。</td></tr><tr><td>Collection<v>values()</v></td><td>返回此映射中包含的值得Collection视图。</td></tr><tr><td>Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet()</td><td>返回此映射中包含的映射关系的Set视图。</td></tr></tbody></table><h3 id="HashMap集合"><a href="#HashMap集合" class="headerlink" title="HashMap集合"></a>HashMap集合</h3><blockquote><p><strong>HashMap</strong>是Map接口的一个实现类，用于存储键值映射关系。</p></blockquote><p>HashSet的遍历方式有二种，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//第一种 for-each方法遍历</span><br><span class="line">for (String key:hash.keySet())&#123;</span><br><span class="line">      System.out.println(&quot;Key:&quot;+key+&quot;  Value:&quot;+hash.get(key)); </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">//第二种 通过Map的entrySet方法  容量大时这种方法遍历最快</span><br><span class="line">for(Map.Entry&lt;String,String&gt;entry:hash.entrySet())&#123;</span><br><span class="line">      System.out.println(&quot;Key :&quot;+entry.getKey()+&quot; Value:&quot;+entry.getValue());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">//第三种 Iterator迭代器 keySet()方法遍历</span><br><span class="line">Iterator &lt;String&gt; iter= hash.keySet().iterator();</span><br><span class="line">while(iter.hasNext())&#123;</span><br><span class="line">      String key=iter.next();</span><br><span class="line">      System.out.println(&quot;Key :&quot;+key+&quot; Value:&quot;+hash.get(key));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">//第四种 Iterator迭代器 entrySet()方法遍历</span><br><span class="line">Iterator iter1=hash.entrySet().iterator();</span><br><span class="line">   while(iter1.hasNext())&#123;</span><br><span class="line">      Map.Entry&lt;String,String&gt; entry=(Map.Entry&lt;String,String&gt;)iter1.next();</span><br><span class="line">      System.out.println(&quot;Key :&quot;+entry.getKey()+&quot; Value:&quot;+entry.getValue()); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Hashtable集合"><a href="#Hashtable集合" class="headerlink" title="Hashtable集合"></a>Hashtable集合</h3><blockquote><p><strong>Hashtable</strong>集合和HashMap集合非常相似，区别在于Hashtable是线程安全的。而它存取速度很慢，所以大部分已被HashMap代替。</p></blockquote><p><strong>Properties</strong>是Hsahtable的一个实现类，主要用于存取应用的配置项。</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>setProperty()</td><td>用于将配置项的键和值添加到集合中。</td></tr><tr><td>getProperty()</td><td>用于获取得到的键所对应的值。</td></tr></tbody></table><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties p = new Properties ();    //创建Properties对象</span><br><span class="line">   ...                               //添加内容</span><br><span class="line">Enumeration name = p.propertyNames();</span><br><span class="line">while ( name.hasMoreElements() ) &#123;</span><br><span class="line">   String key = (String) name.nextElement();</span><br><span class="line">   String value = p.getProperty(key);</span><br><span class="line">   System.out.println(key +&quot;=&quot; + value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h2><blockquote><p><strong>Iterator</strong>接口主要用于迭代访问（遍历）Collection中的元素，也称为迭代器。</p></blockquote><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>E next()</td><td>返回迭代的下一个元素</td></tr><tr><td>boolean hasNext()</td><td>如果仍有元素迭代，则返回true。</td></tr></tbody></table><h3 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h3><blockquote><p>foreach循环用于解决迭代器书写麻烦的问题，但使用foreach遍历集合中的元素时，只能访问，不能进行修改。</p></blockquote><p>语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(容器中元素的类型 临时变量:容器变量&#123;</span><br><span class="line">   代码结构体</span><br><span class="line">   ......</span><br><span class="line">   )</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java一API</title>
      <link href="/2019/10/16/Java%E4%B8%80API/"/>
      <url>/2019/10/16/Java%E4%B8%80API/</url>
      
        <content type="html"><![CDATA[<blockquote><p>API（Application Progranmming Interface)应用程序编程接口。Java编译语言本身，便提供了很多可以自己使用的类，或者是某些公司自己开发的类，这些可以直接使用的类，便叫做API。</p></blockquote><h3 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h3><p><strong>String</strong>类常用于封装字符串。字符串包括一切能够在pc上输入的数据类型。</p><h4 id="String类的构造方法"><a href="#String类的构造方法" class="headerlink" title="String类的构造方法"></a>String类的构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = new String ();</span><br><span class="line">String str2 = &quot;abc&quot;;</span><br><span class="line">String str3 = new String (chr);</span><br><span class="line">//chr为一个数组</span><br></pre></td></tr></table></figure><h4 id="判断功能"><a href="#判断功能" class="headerlink" title="判断功能"></a>判断功能</h4><table><thead><tr><th>方法声明</th><th>功能描述</th><th>代码实现</th></tr></thead><tbody><tr><td>boolean equals(Object anObject)</td><td>将此字符串与指定对象进行比较。</td><td>trfa=str1.equals(str2);</td></tr><tr><td>boolean equalsIgnoreCase(String anotherString)</td><td>将此String与其他String比较，忽略案例注意事项。</td><td>trfa=str1.equalsIgnreCase(str2);</td></tr><tr><td>boolean isEmpty()</td><td>判断字符串是否为空</td><td>trfa=str.isEmpty();</td></tr><tr><td>boolean startsWith(String prefix)</td><td>测试此字符串是否以指定的前缀开头。</td><td>trfa=str1.startWith(str2);</td></tr><tr><td>boolean endsWith(String suffix)</td><td>测试此字符串是否以指定的后缀结尾。</td><td>trfa=str1.endsWith(str2);</td></tr></tbody></table><h4 id="查询功能"><a href="#查询功能" class="headerlink" title="查询功能"></a>查询功能</h4><table><thead><tr><th>方法声明</th><th>功能描述</th><th>代码实现</th></tr></thead><tbody><tr><td>char charAt(int index)</td><td>返回char指定索引处的值。</td><td>ch=chr.charAt(int x);</td></tr><tr><td>int indexOf(int ch)</td><td>返回指定字符在字符串中第一次出现的索引。</td><td>in=str.indexOf(“a”);</td></tr><tr><td>int indexOf(String str)</td><td>返回指定子字符串第一次出现的字符串内的索引。</td><td>in=str.indexOf(str);</td></tr><tr><td>int indexOf(int ch, int fromIndex)</td><td>返回指定位置之后再次出现此字符的索引.</td><td>in=str.indexOf(“a”,6);</td></tr><tr><td>int indexOf(String str, int fromIndex)</td><td>返回指定位置之后再次出现此字符串的索引in=str.indexOf(str,6);</td><td></td></tr><tr><td>String substring(int beginIndex)</td><td>返回一个字符串，该字符串是此字符串的子字符串。</td><td>str=str1.substring(4);</td></tr><tr><td>String substring(int beginIndex, int endIndex)</td><td>返回一个字符串，该字符串是此字符串的开始和结束位置子字符串。</td><td>str=str1.substring(3，4)；</td></tr></tbody></table><h4 id="转换功能"><a href="#转换功能" class="headerlink" title="转换功能"></a>转换功能</h4><table><thead><tr><th>方法声明</th><th>功能描述</th><th>代码实现</th></tr></thead><tbody><tr><td>String valueOf（数据类型</td><td>将任意的数据类型转换成字符串。</td><td>str=String.valueOf(int x);</td></tr><tr><td>String toLowerCase()</td><td>使用默认语言环境的规则将此String中的所有字符转换为小写。</td><td>str=str1.toLoweCase();</td></tr><tr><td>String toUpperCase()</td><td>使用默认语言环境的规则将此String中的所有字符转换为大写。</td><td>str=str1.toUpperCase();</td></tr><tr><td>String concat(String str)</td><td>将指定的字符串连接到该字符串的末尾。</td><td>str=str1.concat(str2);</td></tr><tr><td>char[] toCharArray()</td><td>将此字符串转换为一个字符数组。</td><td>ch[]=str.toCharArray();</td></tr><tr><td>String [] split(“:”)</td><td>根据指定的字符信息将String进行拆分。</td><td>String [] str1 = str2.split(“:”);</td></tr></tbody></table><h4 id="替换功能"><a href="#替换功能" class="headerlink" title="替换功能"></a>替换功能</h4><table><thead><tr><th>方法声明</th><th>功能描述</th><th>代码实现</th></tr></thead><tbody><tr><td>String replace(char oldChar, char newChar)</td><td>返回一个新的字符串，它是由字符替换得到的。</td><td>str.replace（”a”,”b”;）</td></tr><tr><td>String replace(String oldString, String newString)</td><td>返回一个新的字符串，它是字符串替换得到的替换。</td><td>str.replace(str1,str2);</td></tr></tbody></table><h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><blockquote><p>由于字符串是常量，一旦创建就无法修改长度和内容。<strong>StringBuffer</strong>类被称为（字符串缓冲区），其特点是可以修改内容和长度，且不会产生新的StringBuffer对象。主要用于添加和删除字符的操作。<br>String toString()  返回字符缓冲区的字符串  sb.toString();</p></blockquote><h4 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h4><table><thead><tr><th>方法声明</th><th>功能描述</th><th>代码实现</th></tr></thead><tbody><tr><td>StringBuffer append(char c)</td><td>在末尾添加字符串。</td><td>sb.append(“ahfjfjgk”);</td></tr><tr><td>StringBuffer insert(int offset,String str)</td><td>在指定位置的插入字符串。</td><td>sb.insert(2,”jfhg”);</td></tr></tbody></table><h4 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h4><table><thead><tr><th>方法声明</th><th>功能描述</th><th>代码实现</th></tr></thead><tbody><tr><td>StringBuffer deleteCharAt(int index)</td><td>删除指定位置以后的字符。</td><td>sb.deleteCharAt(2);</td></tr><tr><td>StringBuffer delete(int start,int end)</td><td>删除指定范围的字符或字符串。</td><td>sb.delete(2,6);</td></tr></tbody></table><h4 id="修改功能"><a href="#修改功能" class="headerlink" title="修改功能"></a>修改功能</h4><table><thead><tr><th>方法声明</th><th>功能描述</th><th>代码实现</th></tr></thead><tbody><tr><td>StringBuffer replace(int start,int end,String str)</td><td>替换指定位置的字符或字符串。</td><td>sb.replace(1,3,”qqq”);</td></tr><tr><td>void setCharAt(int index,char ch)</td><td>修改指定位置的字符。</td><td>sb.setCharAt(3,”hdh”);</td></tr><tr><td>StringBuffer reverse()</td><td>将字符串反转。</td><td>sb.reverse();</td></tr></tbody></table><h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><blockquote><p><strong>System</strong>类定义了一些与系统相关的属性和方法，切他提供的方法都是静态的，因此可以直接调用。</p></blockquote><table><thead><tr><th>方法声明</th><th>功能描述</th><th>代码实现</th></tr></thead><tbody><tr><td>static void exit(int status)</td><td>执行后终结Java虚拟机，status表示状态，非零则表示异常。</td><td>System.exit(int x);</td></tr><tr><td>static void gc()</td><td>运行垃圾回收器进行垃圾回收。</td><td>System.gc();</td></tr><tr><td>static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)</td><td>引用数组的复制。</td><td>System.arraycopy(Object src,int srcPos,Object dest,int destPos,int length)</td></tr><tr><td>static native long currentTimeMillis()</td><td>返回以毫秒为单位的当前时间。</td><td>System.currentTimeMillis();</td></tr><tr><td>static String getProperty(String key)</td><td>获取指定描述键的系统属性。</td><td>System.getProperty(String key);</td></tr><tr><td>static Properties getProperties()</td><td>获取当前的系统属性。</td><td>SystemgetProperties();</td></tr></tbody></table><h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><blockquote><p><strong>Random</strong>类用于产生随机数，但需要在Java中加上头文件。</p></blockquote><table><thead><tr><th>方法声明</th><th>功能描述</th><th>代码实现</th></tr></thead><tbody><tr><td>Random()</td><td>构造方法，用于创建一个伪随机数生成器。</td><td>Random r = new Random ();</td></tr><tr><td>Random(long seed)</td><td>构造方法，使用一个long型的seed种子创建伪随机数生成器。</td><td>Random r = new Random(12);</td></tr><tr><td>boolean nextBoolean()</td><td>随机生成boolean类型的随机数。</td><td>r.nextBoolean();</td></tr><tr><td>double nextDouble()</td><td>随机生成Double类型的随机数。</td><td>r.nextDouble();</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java一异常</title>
      <link href="/2019/10/12/Java%E4%B8%80%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/10/12/Java%E4%B8%80%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>异常是一种体系，用于表达程序中特殊情况的一种手段。在程序中，可能会出现某些情况，例如给用户的年龄赋值的时候，可能会错误录入，（比如负数，符号等）出现这种情况是不符合生活的正常状态的时候就认为是一个异常，在通过异常处理机制对程序运行时发生的种种问题进行处理。</p></blockquote><h2 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h2><p><img src="/images/Throwable%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="异常"></p><ul><li>Error类：错误类，它表示Java运行时的系统内部错误或资源耗尽的错误，是比较严重的，仅靠修改程序本身是不能恢复执行的。</li><li>Exception类：异常类，表示程序本身可以处理的错误。</li></ul><h3 id="Throwable常用方法"><a href="#Throwable常用方法" class="headerlink" title="Throwable常用方法"></a>Throwable常用方法</h3><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>String getMessage ()</td><td>返回此throwable的详细信息字符串</td></tr><tr><td>String toString ()</td><td>获取异常对象中的简短描述</td></tr><tr><td>String getCause()</td><td>获取异常对象中的原因异常对象</td></tr><tr><td>void printStackTrace ()</td><td>将此throwable及其追踪输出到标椎错误流</td></tr><tr><td>void printStackRrace (PrintStream s)</td><td>将此throwable及其追踪输出到指定的输出流</td></tr></tbody></table><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;输入除数&quot;);</span><br><span class="line">                getNum(new Scanner(System.in).nextInt());     //当输入0的时候会出现异常,和输入不匹配异常。</span><br><span class="line">            &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">                System.out.println(&quot;除数不能为0&quot;);</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">                System.out.println(e.toString());</span><br><span class="line">                System.out.println(e.getCause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static void getNum(int i) &#123;</span><br><span class="line">        System.out.println(10 / i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">除数不能为0</span><br><span class="line">/ by zero</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h2 id="异常的处理方式"><a href="#异常的处理方式" class="headerlink" title="异常的处理方式"></a>异常的处理方式</h2><h3 id="对异常进行捕获解决"><a href="#对异常进行捕获解决" class="headerlink" title="对异常进行捕获解决"></a>对异常进行捕获解决</h3><h4 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h4><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   可能出现异常的代码</span><br><span class="line">&#125; catch (异常类型1 异常名称1) &#123;</span><br><span class="line">   针对异常类型1的处理方案</span><br><span class="line">&#125; catch (异常类型2 异常名称2) &#123;</span><br><span class="line"> 针对异常类型2的处理方案</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125; catch (异常类型n 异常名称n) &#123;</span><br><span class="line"> 针对异常类型n的处理方案</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><blockquote><p>（1）执行try语句。<br>（2）如果没有异常，当try执行完毕时就算完成了。<br>（3）如果在执行try语句的时候，出现了异常，就在catch中声明的异常依次进行匹配（catch括号里面的），如果匹配成功，就执行针对这种异常的处理方案；如果没有匹配成功，就按照jvm默认的处理方式来处理</p></blockquote><h4 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h4><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"> 可能出现异常的代码</span><br><span class="line">&#125; catch (可能出现的异常类型 异常名称) &#123;</span><br><span class="line"> 这种异常的处理方案</span><br><span class="line">&#125; finally &#123;</span><br><span class="line"> 一定会执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><blockquote><p>（1）执行try语句。<br>（2）如果没有异常，当try执行完毕就执行finally语句。<br>（3）如果在执行try语句的时候，出现了异常，就在catch中声明的异常进行匹配（catch括号里面的），无论是否匹配成功，都执行finally语句。</p></blockquote><p>finally作用：一般用来关闭资源。</p><h4 id="try…finally"><a href="#try…finally" class="headerlink" title="try…finally"></a>try…finally</h4><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  可能出现异常的代码</span><br><span class="line">&#125; finally &#123;</span><br><span class="line"> 一定要执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：</p><blockquote><p>将try中的代码和finally中的代码，分离开，不会因为try中代码的执行失败，影响到finally中的代码的执行.</p></blockquote><h2 id="throws关键字"><a href="#throws关键字" class="headerlink" title="throws关键字"></a>throws关键字</h2><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名称(参数列表) throws 异常类型1, 异常类型2... &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：对面声明该方法有可能发生出现异常。</p><h2 id="throw关键字"><a href="#throw关键字" class="headerlink" title="throw关键字"></a>throw关键字</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作用：将一个异常对象抛出，实现程序的跳转或结束。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java一面向对象</title>
      <link href="/2019/10/09/Java%E4%B8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/10/09/Java%E4%B8%80%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面向对象是一种复合人类的思维习惯的变成思想。面向对象3个使用特点分别是：<strong>封装性，继承性，多态性</strong>。封装性是将对象的属性和行为封装起来，继承性是指一个类的属性可以被其它类继承，多态性是指程序中允许出现同名现象。</p></blockquote><h2 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class 类名&#123;</span><br><span class="line">    成员变量</span><br><span class="line">    ...</span><br><span class="line">    成员方法</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="类的权限"><a href="#类的权限" class="headerlink" title="类的权限"></a>类的权限</h3><p>在类的定义中，可以对类的成员进行相关的私有化设置，使其用于特殊的情况之中。可以用 <strong>public</strong> 和 <strong>private</strong> 来修饰成员变量和成员方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public 成员变量/成员方法;</span><br><span class="line">private 成员变量/成员方法;</span><br></pre></td></tr></table></figure><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p>对于那些特定且在内存中只有一份的变量或者是那些想要使用该方法不必和对象绑定的方法可以用 <strong>static 关键字</strong>将其变成静态变量或者是静态方法。<br><strong>static关键字</strong>修饰的方法，其方法体中的常量一定是静态的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//静态变量</span><br><span class="line">ststic 数据类型 变量名;</span><br><span class="line">//静态方法</span><br><span class="line">static 返回值类型 成员方法（）&#123;</span><br><span class="line">    执行语句</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">//调用方法</span><br><span class="line">类名.变量名/方法名</span><br></pre></td></tr></table></figure><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final关键字用于修饰类、变量和方法。被final修饰具有以下特征：<br>1.final修饰的类不能被继承。<br>2.final修饰的方法不能被子类重写。<br>3.final修饰的变量（成员变量和局部变量）是常量，只能赋值一次。</p><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final class 类名&#123;</span><br><span class="line">   final int 变量名;</span><br><span class="line">   final void 方法名（）&#123;</span><br><span class="line">   方法体</span><br><span class="line">   ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><h3 id="继承的定义"><a href="#继承的定义" class="headerlink" title="继承的定义"></a>继承的定义</h3><p>继承描述的是事物之间的所属关系，继承可以分为父类和子类，一个父类可以有多个子类，而一个子类只能拥有一个父类。在程序中，子类会自动继承父类所有可继承的属性和方法，需要使用<strong>extends</strong>关键字修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">class B extends A&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="父类的方法的重写与调用"><a href="#父类的方法的重写与调用" class="headerlink" title="父类的方法的重写与调用"></a>父类的方法的重写与调用</h3><p>当父类的方法被子类重写时，在调用则优先调用被定义类的方法。由于种种原因，当子类的属性或方法与父类的属性或方法发生冲突时，可以直接修改子类的属性或方法。当子类方法被修改时，可以使用<strong>super</strong>关键字进行父类方法的调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//父类方法的重写</span><br><span class="line">class A&#123;</span><br><span class="line">   void shout&#123;</span><br><span class="line">   System.out.println(&quot;父类方法&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">   void shout&#123;</span><br><span class="line">   System.out.println(&quot;子类方法&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">//父类方法的调用</span><br><span class="line">super.成员变量</span><br><span class="line">super.成员方法（参数）</span><br></pre></td></tr></table></figure><h2 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h2><p>在设计一个类时，通常要考虑方法的通用性。多态就是根据传入数据的类型和个数不同，来实现类的多态。<br>多态使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  void speak()&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  void speak ()&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  void sleep ()&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Anmial &#123;</span><br><span class="line">  void speak ()&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  void sleep ()&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">main&#123;</span><br><span class="line">  Animal cat = new Cat （）；           //向上转型</span><br><span class="line">  Animal dog = new Dog （）；           //向上转型</span><br><span class="line">  cat.speak();                          //调用子类的方法</span><br><span class="line">  dog.speak();</span><br><span class="line">  animalSleep(cat);                     //调用方法</span><br><span class="line">  animalSleep(dog);                     </span><br><span class="line">&#125;</span><br><span class="line">public static void animalSleep (Animal an)&#123;</span><br><span class="line">  an.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类和父类之间的类型可以转换,代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Animal为Cat的父类</span><br><span class="line">Animal animal = new Cat （）；          //向上转型，用父类的引用变量去引用子类的实例,只可以访问父类和子类都有的方法或变量。</span><br><span class="line">Cat cat = （Cat）animal;                //向下转型，编译成功，运行成功。将animal类转换为Cat类，则可以访问子类的所有方法。</span><br><span class="line"></span><br><span class="line">Animal animal = new Animal ();</span><br><span class="line">Cat cat1 = (Cat)animal ();              //向下转型，编译成功，运行失败。</span><br></pre></td></tr></table></figure><h3 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h3><p>用于判断当前对象是否可以强制转换类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对象(或者对象引用变量) instanceof 类（接口）</span><br><span class="line"></span><br><span class="line">if (animal instanceof Cat)&#123;</span><br><span class="line">  .....</span><br><span class="line">   &#125; else &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在定义一个类时，需要定义方法来描述类的特征，而方法有时不明确，则需要使用<strong>abstract</strong>关键字修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract class 类名&#123;</span><br><span class="line">       abstract int 方法名()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>抽象类只需要在类定义时加上<strong>abstract</strong>关键字。包含抽象方法的类一定是抽象类，单抽象类不一定包含抽象方法。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>如果一个类的所有方法都是抽象的，则可以用<em>接口</em>来定义这个类，接口用<strong>interface</strong>关键字修饰。接口是由常量和抽象方法组成的特殊类，其接口是抽象类的进一步抽象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[public] interface 接口名 [extends 接口1，接口2…]&#123;</span><br><span class="line">     数据类型 常量名=常量值;</span><br><span class="line">     返回值  抽象方法名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java使用接口的目的是克服单继承的限制，因为一个类只有一个父类，而一个类可以实现多个接口。接口中的变量默认为public static final修饰的全局常量，方法默认为public abstarct修饰抽象方法。若接口声明为public，则变量和方法全部为public。</p><p>1.接口中的属性只能是常量。<br>2.当类继承接口时，若类为抽象类，无需实现接口中的所有抽象方法，反正则需要全部声明。<br>3.如果类要是继承一个接口，则需要<strong>implements</strong>关键字修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class &lt;类名&gt; [extends &lt;父类名&gt;] [implements &lt;接口1&gt;,&lt;接口2&gt;…]&#123;</span><br><span class="line">    方法体</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java一语句</title>
      <link href="/2019/10/03/Java%E4%B8%80%E5%BE%AA%E7%8E%AF/"/>
      <url>/2019/10/03/Java%E4%B8%80%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在编译语言中，有着这样一种语法结构，目的是减少代码的长度，使代码更加简单方便，同时也更方便编译者的理解。大体可以分为选择和循环。</p></blockquote><h1 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h1><p>   <em>选择语句需要对一些条件进行判断，从而决定执行那一行代码，选择语句可以分为if和switch两种！</em></p><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p>if语句常用于对于条件的判断，根据其逻辑结构可以分为3种。</p><h3 id="if选择语句"><a href="#if选择语句" class="headerlink" title="if选择语句"></a>if选择语句</h3><p>使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（条件语句）&#123;代码块&#125;</span><br></pre></td></tr></table></figure><h3 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h3><p>使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（判断语句）&#123;执行语句1&#125;</span><br><span class="line">             <span class="keyword">else</span> &#123;执行语句2&#125;</span><br></pre></td></tr></table></figure><h3 id="if…else-if-…else语句"><a href="#if…else-if-…else语句" class="headerlink" title="if…else if …else语句"></a>if…else if …else语句</h3><p>使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（判断语句）&#123;执行语句1&#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>（判断语句）&#123;执行语句2&#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;执行语句3&#125;</span><br></pre></td></tr></table></figure><h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><p>   <em>switch是一种选择语句，工作原理是根据给定的值进行判断，看它执行哪一行语句。</em></p><p>使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">switch（表达式）&#123;</span><br><span class="line">             <span class="keyword">case</span> 目标值1：</span><br><span class="line">         执行语句1</span><br><span class="line"> <span class="built_in">break</span>；</span><br><span class="line">     <span class="keyword">case</span> 目标值2：</span><br><span class="line">         执行语句2</span><br><span class="line"> <span class="built_in">break</span>；</span><br><span class="line">     ......</span><br><span class="line">     <span class="keyword">case</span> 目标值n：</span><br><span class="line">         执行语句n</span><br><span class="line"> <span class="built_in">break</span>；</span><br><span class="line">     default:</span><br><span class="line">         执行语句n+1</span><br><span class="line"> <span class="built_in">break</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p><em>循环语句可以实现一段代码的重复执行，当其不满足条件时就会跳出循环。循环语句可以分为 while,do…while和for!</em></p><h2 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h2><p>使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>（循环条件）&#123;</span><br><span class="line">   执行语句</span><br><span class="line">   ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="do…while-循环语句"><a href="#do…while-循环语句" class="headerlink" title="do…while 循环语句"></a>do…while 循环语句</h2><p>使用方法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">   执行语句</span><br><span class="line">   ...</span><br><span class="line">&#125; <span class="keyword">while</span> (循环条件)</span><br></pre></td></tr></table></figure><h2 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h2><p>使用方法；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达使;循环条件;操作表达式)&#123;</span><br><span class="line">    执行语句</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h1><p>*跳转语句用于结束循环，可分为两种break和continue！</p><h2 id="break-结束循环"><a href="#break-结束循环" class="headerlink" title="break 结束循环"></a>break 结束循环</h2><h2 id="continue-结束本次循环"><a href="#continue-结束本次循环" class="headerlink" title="continue 结束本次循环"></a>continue 结束本次循环</h2><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>方法指的是一段可重复调用的代码，也称函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名 （[参数类型 参数名1,参数类型 参数名2,........]）&#123;</span><br><span class="line">执行语句</span><br><span class="line">...</span><br><span class="line">return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修饰符：静态修饰符static，最终修饰符final<br>返回值类型：若无返回值，则声明为void</p><h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>即方法支持重载，则在方法中可以允许方法名相同，参数的个数或参数类型不相同。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
